##
## redland.pod - redland Unix manual page
##
## $Id: redland.pod,v 1.4 2003/08/28 15:53:08 cmdjb Exp $
##
## Copyright (C) 2002 David Beckett - http://purl.org/net/dajobe/
## Institute for Learning and Research Technology - http://www.ilrt.org/
## University of Bristol - http://www.bristol.ac.uk/
## 
## This package is Free Software or Open Source available under the
## following licenses (these are alternatives):
##   1. GNU Lesser General Public License (LGPL)
##   2. GNU General Public License (GPL)
##   3. Mozilla Public License (MPL)
## 
## See LICENSE.html or LICENSE.txt at the top of this package for the
## full license terms.
## 
## 

=pod

=head1 NAME

B<redland> - Redland RDF Library

=head1 VERSION

redland REDLAND_VERSION_STRING

=head1 SYNOPSIS

 #include <librdf.h>

=head1 DESCRIPTION

The B<redland> library is a general RDF library written in ANSI C
that provides application support for the RDF model,

This manual page is INCOMPLETE.  See the HTML API documentation for
full details on the interfaces either on the Redland web site
http://www.redland.opensource.ac.uk/ or with the software release in
the docs/api directory.  Documentation on the Perl and Python
APIs in POD and Pydoc respectively are also available.

=head1 FUNCTIONS

The functions defined by B<redland> are all defined with the
C<librdf_> prefix

=head2 class world

=over 4

=item librdf_world* B<librdf_new_world>(I<void>);

=item void B<librdf_free_world>(librdf_world *I<world>);

=item void B<librdf_world_open>(librdf_world *I<world>);

=item void B<librdf_world_set_error>(librdf_world* I<world>, void *I<user_data>, void (*I<error_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item void B<librdf_world_set_warning>(librdf_world* I<world>, void *I<user_data>, void (*I<warning_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item void B<librdf_world_set_digest>(librdf_world*, const char *I<name>);

=item void B<librdf_world_set_uris_hash>(librdf_world* I<world>, librdf_hash* I<uris_hash>);

=item const char *B<librdf_world_get_feature>(librdf_world* I<world>, librdf_uri *I<feature>);

=item int B<librdf_world_set_feature>(librdf_world* I<world>, librdf_uri *I<feature>, const char *I<value>);

=item void B<librdf_init_world>(char *I<digest_factory_name>, librdf_hash* I<uris_hash>);

=item void B<librdf_destroy_world>(I<void>);

=back

=head2 class iterator

=over 4

=item librdf_iterator* B<librdf_new_iterator>(librdf_world *I<world>, void *I<context>, int (*I<is_end>)(void*), void* (*I<get_next>)(void*), void (*I<finished>)(void*));

=item void B<librdf_free_iterator>(librdf_iterator*);

=item int B<librdf_iterator_end>(librdf_iterator* I<iterator>);

=item int B<librdf_iterator_have_elements>(librdf_iterator* I<iterator>);

=item int B<librdf_iterator_finished>(librdf_iterator* I<iterator>);

=item void* B<librdf_iterator_get_next>(librdf_iterator* I<iterator>);

=item int B<librdf_iterator_add_map>(librdf_iterator* I<iterator>, void* (*I<fn>)(void *I<context>, void *I<item>), void *I<context>);

=item void* B<librdf_iterator_map_remove_duplicate_nodes>(void *I<item>, void *I<user_data>);

=back

=head2 class digest

=over 4

=item void B<librdf_digest_register_factory>(librdf_world *I<world>, const char *I<name>, void (*I<factory>) (librdf_digest_factory*));

=item librdf_digest_factory* B<librdf_get_digest_factory>(librdf_world *I<world>, const char *I<name>);

=item void B<librdf_init_digest>(librdf_world *I<world>);

=item void B<librdf_finish_digest>(librdf_world *I<world>);

=item librdf_digest* B<librdf_new_digest>(librdf_world *I<world>, char *I<name>);

=item librdf_digest* B<librdf_new_digest_from_factory>(librdf_world *I<world>, librdf_digest_factory *I<factory>);

=item void B<librdf_free_digest>(librdf_digest *I<digest>);

=item void B<librdf_digest_init>(librdf_digest* I<digest>);

=item void B<librdf_digest_update>(librdf_digest* I<digest>, unsigned char *I<buf>, size_t I<length>);

=item void B<librdf_digest_final>(librdf_digest* I<digest>);

=item void* B<librdf_digest_get_digest>(librdf_digest* I<digest>);

=item char* B<librdf_digest_to_string>(librdf_digest* I<digest>);

=item void B<librdf_digest_print>(librdf_digest* I<digest>, FILE* I<fh>);

=back

=head2 class uri

=over 4

=item void B<librdf_init_uri>(librdf_world *I<world>);

=item void B<librdf_finish_uri>(librdf_world *I<world>);

=item void B<librdf_free_uri>(librdf_uri *I<uri>);

=item int B<librdf_uri_equals>(librdf_uri* I<first_uri>, librdf_uri* I<second_uri>);

=item int B<librdf_uri_is_file_uri>(librdf_uri* I<uri>);

=item const char* B<librdf_uri_as_filename>(librdf_uri* I<uri>);

=item librdf_uri* B<librdf_new_uri_normalised_to_base>(const char *I<uri_string>, librdf_uri* I<source_uri>, librdf_uri* I<base_uri>);

=item librdf_uri* B<librdf_new_uri_relative_to_base>(librdf_uri* I<base_uri>, const char *I<uri_string>);

=back

=head2 class node

=over 4

=item void B<librdf_init_node>(librdf_world* I<world>);

=item void B<librdf_finish_node>(librdf_world* I<world>);

=item librdf_node* B<librdf_new_node>(librdf_world* I<world>);

=item librdf_node* B<librdf_new_node_from_uri_string>(librdf_world* I<world>, const char *I<string>);

=item librdf_node* B<librdf_new_node_from_uri>(librdf_world* I<world>, librdf_uri *I<uri>);

=item librdf_node* B<librdf_new_node_from_uri_local_name>(librdf_world* I<world>, librdf_uri *I<uri>, const char *I<local_name>);

=item librdf_node* B<librdf_new_node_from_normalised_uri_string>(librdf_world* I<world>, const char *I<uri_string>, librdf_uri *I<source_uri>, librdf_uri *I<base_uri>);

=item librdf_node* B<librdf_new_node_from_literal>(librdf_world* I<world>, const char *I<string>, const char *I<xml_language>, int I<xml_space>, int I<is_wf_xml>);

=item librdf_node* B<librdf_new_node_from_node>(librdf_node *I<node>);

=item void B<librdf_node_init>(librdf_world *I<world>, librdf_node *I<node>);

=item void B<librdf_free_node>(librdf_node *I<r>);

=item librdf_uri* B<librdf_node_get_uri>(librdf_node* I<node>);

=item int B<librdf_node_set_uri>(librdf_node* I<node>, librdf_uri *I<uri>);

=item librdf_node_type B<librdf_node_get_type>(librdf_node* I<node>);

=item void B<librdf_node_set_type>(librdf_node* I<node>, librdf_node_type I<type>);

=item char* B<librdf_node_get_literal_value>(librdf_node* I<node>);

=item char* B<librdf_node_get_literal_value_as_latin1>(librdf_node* I<node>);

=item char* B<librdf_node_get_literal_value_language>(librdf_node* I<node>);

=item int B<librdf_node_get_literal_value_xml_space>(librdf_node* I<node>);

=item int B<librdf_node_get_literal_value_is_wf_xml>(librdf_node* I<node>);

=item int B<librdf_node_set_literal_value>(librdf_node* I<node>, const char* I<value>, const char *I<xml_language>, int I<xml_space>, int I<is_wf_xml>);

=item int B<librdf_node_get_li_ordinal>(librdf_node* I<node>);

=item void B<librdf_node_set_li_ordinal>(librdf_node* I<node>, int I<ordinal>);

=item librdf_digest* B<librdf_node_get_digest>(librdf_node* I<node>);

=item size_t B<librdf_node_encode>(librdf_node* I<node>, unsigned char *I<buffer>, size_t I<length>);

=item size_t B<librdf_node_decode>(librdf_node* I<node>, unsigned char *I<buffer>, size_t I<length>);

=item char *B<librdf_node_to_string>(librdf_node* I<node>);

=item void B<librdf_node_print>(librdf_node* I<node>, FILE *I<fh>);

=item int B<librdf_node_equals>(librdf_node* I<first_node>, librdf_node* I<second_node>);

=back

=head2 class concepts

=over 4

=item void B<librdf_init_concepts>(librdf_world *I<world>);

=item void B<librdf_finish_concepts>(librdf_world *I<world>);

=item void B<librdf_get_concept_by_name>(librdf_world *I<world>, int I<is_ms>, const char *I<name>, librdf_uri **I<uri_p>, librdf_node **I<node_p>);

=back

=head2 class statement

=over 4

=item void B<librdf_init_statement>(librdf_world *I<world>);

=item void B<librdf_finish_statement>(librdf_world *I<world>);

=item librdf_statement* B<librdf_new_statement>(librdf_world* I<world>);

=item librdf_statement* B<librdf_new_statement_from_statement>(librdf_statement* I<statement>);

=item librdf_statement* B<librdf_new_statement_from_nodes>(librdf_world *I<world>, librdf_node* I<subject>, librdf_node* I<predicate>, librdf_node* I<object>);

=item void B<librdf_statement_init>(librdf_world *I<world>, librdf_statement *I<statement>);

=item void B<librdf_free_statement>(librdf_statement* I<statement>);

=item librdf_node* B<librdf_statement_get_subject>(librdf_statement *I<statement>);

=item void B<librdf_statement_set_subject>(librdf_statement *I<statement>, librdf_node *I<subject>);

=item librdf_node* B<librdf_statement_get_predicate>(librdf_statement *I<statement>);

=item void B<librdf_statement_set_predicate>(librdf_statement *I<statement>, librdf_node *I<predicate>);

=item librdf_node* B<librdf_statement_get_object>(librdf_statement *I<statement>);

=item void B<librdf_statement_set_object>(librdf_statement *I<statement>, librdf_node *I<object>);

=item char *B<librdf_statement_to_string>(librdf_statement *I<statement>);

=item void B<librdf_statement_print>(librdf_statement *I<statement>, FILE *I<fh>);

=item int B<librdf_statement_equals>(librdf_statement* I<statement1>, librdf_statement* I<statement2>);

=item int B<librdf_statement_match>(librdf_statement* I<statement>, librdf_statement* I<partial_statement>);

=item size_t B<librdf_statement_encode>(librdf_statement* I<statement>, unsigned char *I<buffer>, size_t I<length>);

=item size_t B<librdf_statement_encode_parts>(librdf_statement* I<statement>, unsigned char *I<buffer>, size_t I<length>, int I<fields>);

=item size_t B<librdf_statement_decode>(librdf_statement* I<statement>, unsigned char *I<buffer>, size_t I<length>);

=back

=head2 class model

=over 4

=item void B<librdf_init_model>(librdf_world *I<world>);

=item void B<librdf_finish_model>(librdf_world *I<world>);

=item librdf_model* B<librdf_new_model>(librdf_world *I<world>, librdf_storage *I<storage>, char* I<options_string>);

=item librdf_model* B<librdf_new_model_with_options>(librdf_world *I<world>, librdf_storage *I<storage>, librdf_hash* I<options>);

=item librdf_model* B<librdf_new_model_from_model>(librdf_model* I<model>);

=item void B<librdf_free_model>(librdf_model *I<model>);

=item int B<librdf_model_size>(librdf_model* I<model>);

=item int B<librdf_model_add>(librdf_model* I<model>, librdf_node* I<subject>, librdf_node* I<predicate>, librdf_node* I<object>);

=item int B<librdf_model_add_string_literal_statement>(librdf_model* I<model>, librdf_node* I<subject>, librdf_node* I<predicate>, char* I<string>, char *I<xml_language>, int I<xml_space>, int I<is_wf_xml>);

=item int B<librdf_model_add_statement>(librdf_model* I<model>, librdf_statement* I<statement>);

=item int B<librdf_model_add_statements>(librdf_model* I<model>, librdf_stream* I<statement_stream>);

=item int B<librdf_model_remove_statement>(librdf_model* I<model>, librdf_statement* I<statement>);

=item int B<librdf_model_contains_statement>(librdf_model* I<model>, librdf_statement* I<statement>);

=item int B<librdf_model_has_arc_in>(librdf_model *I<model>, librdf_node *I<node>, librdf_node *I<property>);

=item int B<librdf_model_has_arc_out>(librdf_model *I<model>, librdf_node *I<node>, librdf_node *I<property>);

=item librdf_stream* B<librdf_model_as_stream>(librdf_model* I<model>);

=item librdf_stream* B<librdf_model_find_statements>(librdf_model* I<model>, librdf_statement* I<statement>);

=item librdf_iterator* B<librdf_model_get_sources>(librdf_model *I<model>, librdf_node *I<arc>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_model_get_arcs>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_model_get_targets>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<arc>);

=item librdf_node* B<librdf_model_get_source>(librdf_model *I<model>, librdf_node *I<arc>, librdf_node *I<target>);

=item librdf_node* B<librdf_model_get_arc>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<target>);

=item librdf_node* B<librdf_model_get_target>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<arc>);

=item librdf_iterator* B<librdf_model_get_arcs_in>(librdf_model *I<model>, librdf_node *I<node>);

=item librdf_iterator* B<librdf_model_get_arcs_out>(librdf_model *I<model>, librdf_node *I<node>);

=item int B<librdf_model_add_submodel>(librdf_model* I<model>, librdf_model* I<sub_model>);

=item int B<librdf_model_remove_submodel>(librdf_model* I<model>, librdf_model* I<sub_model>);

=item void B<librdf_model_print>(librdf_model *I<model>, FILE *I<fh>);

=item int B<librdf_model_add_statements_group>(librdf_model* I<model>, librdf_uri* I<group_uri>, librdf_stream* I<stream>);

=item int B<librdf_model_remove_statements_group>(librdf_model* I<model>, librdf_uri* I<group_uri>);

=back

=head2 class storage

=over 4

=item void B<librdf_init_storage>(librdf_world *I<world>);

=item void B<librdf_finish_storage>(librdf_world *I<world>);

=item void B<librdf_storage_register_factory>(const char *I<name>, void (*I<factory>) (librdf_storage_factory*));

=item librdf_storage_factory* B<librdf_get_storage_factory>(const char *I<name>);

=item librdf_storage* B<librdf_new_storage>(librdf_world *I<world>, char *I<storage_name>, char *I<name>, char *I<options_string>);

=item librdf_storage* B<librdf_new_storage_from_factory>(librdf_world *I<world>, librdf_storage_factory* I<factory>, char *I<name>, librdf_hash* I<options>);

=item void B<librdf_free_storage>(librdf_storage *I<storage>);

=item int B<librdf_storage_open>(librdf_storage* I<storage>, librdf_model *I<model>);

=item int B<librdf_storage_close>(librdf_storage* I<storage>);

=item int B<librdf_storage_get>(librdf_storage* I<storage>, void *I<key>, size_t I<key_len>, void **I<value>, size_t* I<value_len>, unsigned int I<flags>);

=item int B<librdf_storage_size>(librdf_storage* I<storage>);

=item int B<librdf_storage_add_statement>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item int B<librdf_storage_add_statements>(librdf_storage* I<storage>, librdf_stream* I<statement_stream>);

=item int B<librdf_storage_remove_statement>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item int B<librdf_storage_contains_statement>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item librdf_stream* B<librdf_storage_serialise>(librdf_storage* I<storage>);

=item librdf_stream* B<librdf_storage_find_statements>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item librdf_iterator* B<librdf_storage_get_sources>(librdf_storage *I<storage>, librdf_node *I<arc>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_storage_get_arcs>(librdf_storage *I<storage>, librdf_node *I<source>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_storage_get_targets>(librdf_storage *I<storage>, librdf_node *I<source>, librdf_node *I<arc>);

=item librdf_iterator* B<librdf_storage_get_arcs_in>(librdf_storage *I<storage>, librdf_node *I<node>);

=item librdf_iterator* B<librdf_storage_get_arcs_out>(librdf_storage *I<storage>, librdf_node *I<node>);

=item int B<librdf_storage_has_arc_in>(librdf_storage *I<storage>, librdf_node *I<node>, librdf_node *I<property>);

=item int B<librdf_storage_has_arc_out>(librdf_storage *I<storage>, librdf_node *I<node>, librdf_node *I<property>);

=item int B<librdf_storage_group_add_statement>(librdf_storage* I<storage>, librdf_uri* I<group_uri>, librdf_statement* I<statement>);

=item int B<librdf_storage_group_remove_statement>(librdf_storage* I<storage>, librdf_uri* I<group_uri>, librdf_statement* I<statement>);

=item librdf_stream* B<librdf_storage_group_serialise>(librdf_storage* I<storage>, librdf_uri* I<group_uri>);

=back

=head2 class parser

=over 4

=item void B<librdf_parser_register_factory>(librdf_world *I<world>, const char *I<name>, const char *I<mime_type>, const char *I<uri_string>, void (*I<factory>) (librdf_parser_factory*));

=item librdf_parser_factory* B<librdf_get_parser_factory>(librdf_world *I<world>, const char *I<name>, const char *I<mime_type>, librdf_uri *I<type_uri>);

=item void B<librdf_init_parser>(librdf_world *I<world>);

=item void B<librdf_finish_parser>(librdf_world *I<world>);

=item librdf_parser* B<librdf_new_parser>(librdf_world* I<world>, const char *I<name>, const char *I<mime_type>, librdf_uri *I<type_uri>);

=item librdf_parser* B<librdf_new_parser_from_factory>(librdf_world* I<world>, librdf_parser_factory *I<factory>);

=item void B<librdf_free_parser>(librdf_parser *I<parser>);

=item librdf_stream* B<librdf_parser_parse_as_stream>(librdf_parser* I<parser>, librdf_uri* I<uri>, librdf_uri* I<base_uri>);

=item int B<librdf_parser_parse_into_model>(librdf_parser* I<parser>, librdf_uri* I<uri>, librdf_uri* I<base_uri>, librdf_model* I<model>);

=item void B<librdf_parser_set_error>(librdf_parser* I<parser>, void *I<user_data>, void (*I<error_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item void B<librdf_parser_set_warning>(librdf_parser* I<parser>, void *I<user_data>, void (*I<warning_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item const char *B<librdf_parser_get_feature>(librdf_parser* I<parser>, librdf_uri *I<feature>);

=item int B<librdf_parser_set_feature>(librdf_parser* I<parser>, librdf_uri *I<feature>, const char *I<value>);

=item void B<librdf_parser_error>(librdf_parser* I<parser>, const char *I<message>, ...);

=item void B<librdf_parser_warning>(librdf_parser* I<parser>, const char *I<message>, ...);

=back

=head2 class stream

=over 4

=item librdf_stream* B<librdf_new_stream>(librdf_world *I<world>, void* I<context>, int (*I<end_of_stream>)(void*), librdf_statement* (*I<next_statement>)(void*), void (*I<finished>)(void*));

=item void B<librdf_free_stream>(librdf_stream* I<stream>);

=item int B<librdf_stream_end>(librdf_stream* I<stream>);

=item librdf_statement* B<librdf_stream_next>(librdf_stream* I<stream>);

=item void B<librdf_stream_set_map>(librdf_stream* I<stream>, librdf_statement* (*I<map>)(void* I<context>, librdf_statement* I<statement>), void* I<map_context>);

=item void B<librdf_stream_print>(librdf_stream *I<stream>, FILE *I<fh>);

=back


=head1 EXAMPLES

Would be here


=head1 SEE ALSO

libxml(4).

=head1 HISTORY

The B<redland> library was written by Dave Beckett from around June
2000 onwards.


=head1 AUTHOR

 Dave Beckett
 http://purl.org/net/dajobe/
 Institute for Learning and Research Technology, University of Bristol

=cut
