<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN"[]> <!-- -*- DocBook -*- -->
<book id="redlandAPI">
  <?dbhtml filename='index.html'>
  <bookinfo>
    <date>2003-01-29</date>
    <title>Redland RDF Application Framework API Reference Manual</title>
    <authorgroup>
      <author>
	<firstname>Dave</firstname>
	<surname>Beckett</surname>
	<affiliation>
          <orgname>University of Bristol</orgname>
	  <orgdiv>Institute for Learning and Research Technology (ILRT)</orgdiv>
	  <address>
	    <email>Dave.Beckett@bristol.ac.uk</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2000-2003</year>
      <holder>Dave Beckett, University of Bristol, UK</holder>
      <indexterm>
	<primary>
          <author>
	    <firstname>Dave</firstname>
	    <surname>Beckett</surname>
	    <affiliation>
	      <orgname>University of Bristol</orgname>
	      <orgdiv>Institute for Learning and Research Technology (ILRT)</orgdiv>
	    </affiliation>
	  </author>
         </primary>
      </indexterm>
    </copyright>
    <legalnotice>
      <para>
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the <ulink url="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</ulink>, Version 1.1
      or any later version published by the Free Software Foundation;
      with
        no Invariant Sections, 
      with
        no Front-Cover Texts, and
      with 
        no Back-Cover Texts.
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".

     </para>
    </legalnotice>

    <pubdate role="CVS">$Date: 2003/03/29 21:27:30 $</pubdate>

    <abstract>
      <title>Abstract</title>
      <para>
This document describes the APIs provided by
<ulink url="http://purl.org/net/redland/">Redland</ulink> to use the RDF
model; manipulate statements, resources, predicates and objects in the model;
parse RDF/XML syntax, query and store the models.
      </para>
<para>
See also the <ulink url="http://www.librdf.org/">Redland Home Page</ulink>
and the <ulink url="../README.html">main document overview</ulink>.
</para>

    </abstract>

   </bookinfo>

<toc></toc>

<chapter id="objects">
<?dbhtml filename='objects.html'>
<title>Introduction to Objects in C</title>
<para>
Redland uses objects and is written in C, which has no built in support for
object construction, destruction, copying etc.  This library thus uses
conventions for the names of the routines providing the
constructor, destructor and copy constructor functionality for a class as
well as conventions for the general methods.
</para>
<para>
A class FOO is defined as a C typedef <literal>librdf_foo</literal>,
and its a public interface defined in <filename>rdf_foo.h</filename>
along with any public or private types, enumerations or constants.
The private definitions are not exposed to library users, only
internally when the library is built.  The implementation of the
class is defined in file <filename>rdf_foo.c</filename> and may
include private (static) functions either for internal
implementations or to satisfy part of a factory API.
</para>
<para>Each class may have a class initialiser / termination pair
of functions which must be called before any object in the class is created,
and after the last object has been freed. These are defined with signatures
like:
<programlisting>
  void init_librdf_foo (...)
  void terminate_librdf_foo (void)
</programlisting>
The arguments to the initialisation vary since there are sometimes
some class wide options that can be set at initialisation time.
</para>
<para>
The object constructor(s) are defined with signatures like:
<programlisting>
  librdf_foo* librdf_new_foo(void)
</programlisting>
which takes no parameters.  Additional constructors can be defined
with parameters, and are named in a similar way with an extra part
appropriate for the name for example:
<programlisting>
  librdf_foo* librdf_new_foo_with_options(char *options)
</programlisting>
</para>
<para>A copy constructor may be defined which will have the signature:
<programlisting>
  librdf_foo* librdf_new_foo_from_foo(librdf_foo* old_foo)
</programlisting>
</para>
<para>A destructor must be defined and has the signature:
<programlisting>
  void librdf_free_foo(librdf_foo* foo)
</programlisting>
</para>
<para>Methods of the class have names starting with <literal>librdf_foo_</literal> and
examples could be:
<programlisting>
  /* accessor functions to object part 'thing' */
  int librdf_foo_set_thing(librdf_foo* foo, char *thing)
  char *librdf_foo_get_thing(librdf_foo* foo)
</programlisting>
</para>
<para>It is often convienent to get a string representation of an
object for further processing, debugging or serialisation.  There are
two conventions for methods that provide this functionality - the
first is when a pointer is returned to a <emphasis>shared</emphasis>
copy of the string and in that case the method ends
<literal>_as_string</literal>.  The second is when a pointer is
returned to a <emphasis>newly allocated</emphasis> string in which
case the method ends <literal>_to_string</literal>.</para>
</chapter>

<chapter id="world">
<?dbhtml filename='world.html'>
<title>RDF World</title>
<para>
This module initialises the Redland library and reference all resources
from it.
</para>

<sect1>
<title>RDF World Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="new-world">librdf_new_world</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_world</refname>
 <refpurpose>
   Creates a new Redland execution environment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_world* <function>librdf_new_world </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-world">librdf_free_world</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_world</refname>
 <refpurpose>
      Terminate the library
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_world </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Terminates and frees the resources.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="world-init-mutex">librdf_world_init_mutex</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_world_init_mutex</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_world_init_mutex </function></funcdef>
   <paramdef>librdf_world* <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="world-open">librdf_world_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_world_open</refname>
 <refpurpose>
      Open an environment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_world_open </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="world-set-error">librdf_world_set_error</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_world_set_error</refname>
 <refpurpose>
      Set the world error handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_world_set_error </function></funcdef>
   <paramdef>librdf_world* <parameter>world</parameter></paramdef>
   <paramdef>void * <parameter>user_data</parameter></paramdef>
   <paramdef>void (*<parameter>error_fn</parameter>)
     <funcparams>void *user_data, const char *message, va_list arguments</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_data</parameter></term>
   <listitem>
    <para>
      user data to pass to function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>error_fn</parameter></term>
   <listitem>
    <para>
      pointer to the function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function will receive callbacks when the world fails.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="world-set-warning">librdf_world_set_warning</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_world_set_warning</refname>
 <refpurpose>
      Set the world warning handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_world_set_warning </function></funcdef>
   <paramdef>librdf_world* <parameter>world</parameter></paramdef>
   <paramdef>void * <parameter>user_data</parameter></paramdef>
   <paramdef>void (*<parameter>warning_fn</parameter>)
     <funcparams>void *user_data, const char *message, va_list arguments</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_data</parameter></term>
   <listitem>
    <para>
      user data to pass to function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>warning_fn</parameter></term>
   <listitem>
    <para>
      pointer to the function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function will receive callbacks when the world gives a warning.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="world-set-digest">librdf_world_set_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_world_set_digest</refname>
 <refpurpose>
      Set the default digest name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_world_set_digest </function></funcdef>
   <paramdef>librdf_world* <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      Digest factory name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Sets the digest factory for various modules that need to make
   digests of their objects.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="world-set-uris-hash">librdf_world_set_uris_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_world_set_uris_hash</refname>
 <refpurpose>
      Set the hash object to use for URI class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_world_set_uris_hash </function></funcdef>
   <paramdef>librdf_world* <parameter>world</parameter></paramdef>
   <paramdef>librdf_hash* <parameter>uris_hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uris_hash</parameter></term>
   <listitem>
    <para>
      librdf_hash* hash
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If a uris_hash is given, that is passed to the URIs class
   initialisation and used to store hashes rather than the default
   one, currently an in memory hash.  See <function>librdf_init_uri</function> for details.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="init-world">librdf_init_world</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_world</refname>
 <refpurpose>
      Initialise the library (DEPRECATED)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_world </function></funcdef>
   <paramdef>char * <parameter>digest_factory_name</parameter></paramdef>
   <paramdef>librdf_hash* <parameter>uris_hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest_factory_name</parameter></term>
   <listitem>
    <para>
      Name of digest factory to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uris_hash</parameter></term>
   <listitem>
    <para>
      Hash to store URIs in
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Use librdf_new_world and librdf_world_open on librdf_world object
   </para><para>

   See librdf_world_set_digest_factory_name and
   librdf_world_set_uris_hash for documentation on arguments.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="destroy-world">librdf_destroy_world</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_destroy_world</refname>
 <refpurpose>
      Terminate the library (DEPRECATED)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_destroy_world </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Use librdf_free_world on librdf_world object
   </para><para>

   Terminates and frees the resources.
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="model">
<?dbhtml filename='model.html'>
<title>RDF Model</title>
<para>
This module provides the RDF model support which is a bag of statements
(duplicates are allowed).  Models can have statements added and removed,
be queries and stored which is implemented by the storage classes.
</para>

<sect1>
<title>RDF Model Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="init-model">librdf_init_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_model</refname>
 <refpurpose>
   Initialise librdf_model class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_model </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-model">librdf_finish_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_model</refname>
 <refpurpose>
      Terminate librdf_model class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_model </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-register-factory">librdf_model_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_register_factory</refname>
 <refpurpose>
      Register a model factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_model_register_factory </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>void (*<parameter>factory</parameter>)
     <funcparams>librdf_model_factory*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the model factory name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      pointer to function to call to register the factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="get-model-factory">librdf_get_model_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_get_model_factory</refname>
 <refpurpose>
      Get a model factory by name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_model_factory* <function>librdf_get_model_factory </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the factory name or NULL for the default factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the factory object or NULL if there is no such factory
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-model">librdf_new_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_model</refname>
 <refpurpose>
      Constructor - create a new storage librdf_model object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_model* <function>librdf_new_model </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>char * <parameter>options_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>options_string</parameter></term>
   <listitem>
    <para>
      options to initialise model
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The options are encoded as described in <function>librdf_hash_from_string</function>
   and can be NULL if none are required.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_model</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-model-with-options">librdf_new_model_with_options</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_model_with_options</refname>
 <refpurpose>
      Constructor - Create a new librdf_model with storage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_model* <function>librdf_new_model_with_options </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_hash* <parameter>options</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> storage to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>options</parameter></term>
   <listitem>
    <para>
      <structname>librdf_hash</structname> of options to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Options are presently not used.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_model</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-model-from-model">librdf_new_model_from_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_model_from_model</refname>
 <refpurpose>
      Copy constructor - create a new librdf_model from an existing one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_model* <function>librdf_new_model_from_model </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the existing <structname>librdf_model</structname>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Creates a new model as a copy of the existing model in the same
   storage context.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_model</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-model">librdf_free_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_model</refname>
 <refpurpose>
      Destructor - Destroy a librdf_model object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_model </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> model to destroy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-size">librdf_model_size</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_size</refname>
 <refpurpose>
      get the number of statements in the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_size </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>WARNING</title>
 <para>
    Not all underlying stores can return the size of the graph
   In which case the return value will be negative.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the number of statements or &lt;0 if not possible
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-add-statement">librdf_model_add_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_add_statement</refname>
 <refpurpose>
      Add a statement to the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_add_statement </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      statement object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The passed-in statement is copied when added to the model, not
   shared with the model.  It must be a complete statement - all
   of subject, predicate, object parts must be present.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-add-statements">librdf_model_add_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_add_statements</refname>
 <refpurpose>
      Add a stream of statements to the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_add_statements </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_stream* <parameter>statement_stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement_stream</parameter></term>
   <listitem>
    <para>
      stream of statements to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-add">librdf_model_add</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_add</refname>
 <refpurpose>
      Create and add a new statement about a resource to the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_add </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>subject</parameter></paramdef>
   <paramdef>librdf_node* <parameter>predicate</parameter></paramdef>
   <paramdef>librdf_node* <parameter>object</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subject</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of subject
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>predicate</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of predicate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>object</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of object (literal or resource)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   After this method, the <structname>librdf_node</structname> objects become owned by the model.
   All of subject, predicate and object must be non-NULL.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-add-typed-literal-statement">librdf_model_add_typed_literal_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_add_typed_literal_statement</refname>
 <refpurpose>
      Create and add a new statement about a typed literal to the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_add_typed_literal_statement </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>subject</parameter></paramdef>
   <paramdef>librdf_node* <parameter>predicate</parameter></paramdef>
   <paramdef>char* <parameter>literal</parameter></paramdef>
   <paramdef>char * <parameter>xml_language</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>datatype_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subject</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of subject
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>predicate</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of predicate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>literal</parameter></term>
   <listitem>
    <para>
      string literal content
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xml_language</parameter></term>
   <listitem>
    <para>
      language of literal
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>datatype_uri</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   After this method, the <structname>librdf_node</structname> subject and predicate become
   owned by the model.
   </para><para>

   The language can be set to NULL if not used.
   All of subject, predicate and literal must be non-NULL.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-add-string-literal-statement">librdf_model_add_string_literal_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_add_string_literal_statement</refname>
 <refpurpose>
      Create and add a new statement about a literal to the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_add_string_literal_statement </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>subject</parameter></paramdef>
   <paramdef>librdf_node* <parameter>predicate</parameter></paramdef>
   <paramdef>char* <parameter>literal</parameter></paramdef>
   <paramdef>char * <parameter>xml_language</parameter></paramdef>
   <paramdef>int <parameter>is_wf_xml</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subject</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of subject
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>predicate</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of predicate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>literal</parameter></term>
   <listitem>
    <para>
      string literal conten
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xml_language</parameter></term>
   <listitem>
    <para>
      language of literal
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_wf_xml</parameter></term>
   <listitem>
    <para>
      literal is XML
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The language can be set to NULL if not used.
   All of subject, predicate and literal must be non-NULL.
   </para><para>

   0.9.12: xml_space argument deleted
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-remove-statement">librdf_model_remove_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_remove_statement</refname>
 <refpurpose>
      Remove a known statement from the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_remove_statement </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   It must be a complete statement - all of subject, predicate, object
   parts must be present.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-contains-statement">librdf_model_contains_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_contains_statement</refname>
 <refpurpose>
      Check for a statement in the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_contains_statement </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   It must be a complete statement - all of subject, predicate, object
   parts must be present.  Use librdf_model_find_statements to search
   for partial statement matches.
 </para>
</refsect1>
<refsect1>
 <title>WARNING</title>
 <para>
    librdf_model_contains_statement may not work correctly
   with stores using contexts.  In this case, a search using
   librdf_model_find_statements for a non-empty list will
   return the correct result.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if the model contains the statement
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-as-stream">librdf_model_as_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_as_stream</refname>
 <refpurpose>
      list the model contents as a stream of statements
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_model_as_stream </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a <structname>librdf_stream</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-serialise">librdf_model_serialise</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_serialise</refname>
 <refpurpose>
      serialise the entire model as a stream (DEPRECATED)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_model_serialise </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   DEPRECATED to reduce confusion with the librdf_serializer class.
   Please use librdf_model_as_stream.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a <structname>librdf_stream</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-find-statements">librdf_model_find_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_find_statements</refname>
 <refpurpose>
      find matching statements in the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_model_find_statements </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the partial statement to match
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The partial statement is a statement where the subject, predicate
   and/or object can take the value NULL which indicates a match with
   any value in the model
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a <structname>librdf_stream</structname> of statements (can be empty) or NULL
   on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-sources">librdf_model_get_sources</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_sources</refname>
 <refpurpose>
      return the sources (subjects) of arc in an RDF graph given arc (predicate) and target (object)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_model_get_sources </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>arc</parameter></paramdef>
   <paramdef>librdf_node * <parameter>target</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arc</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> arc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> target
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the model for arcs matching the given arc and target
   and returns a list of the source <structname>librdf_node</structname> objects as an iterator
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-arcs">librdf_model_get_arcs</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_arcs</refname>
 <refpurpose>
      return the arcs (predicates) of an arc in an RDF graph given source (subject) and target (object)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_model_get_arcs </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>source</parameter></paramdef>
   <paramdef>librdf_node * <parameter>target</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> target
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the model for arcs matching the given source and target
   and returns a list of the arc <structname>librdf_node</structname> objects as an iterator
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-targets">librdf_model_get_targets</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_targets</refname>
 <refpurpose>
      return the targets (objects) of an arc in an RDF graph given source (subject) and arc (predicate)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_model_get_targets </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>source</parameter></paramdef>
   <paramdef>librdf_node * <parameter>arc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arc</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> arc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the model for targets matching the given source and arc
   and returns a list of the source <structname>librdf_node</structname> objects as an iterator
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-source">librdf_model_get_source</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_source</refname>
 <refpurpose>
      return one source (subject) of arc in an RDF graph given arc (predicate) and target (object)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_model_get_source </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>arc</parameter></paramdef>
   <paramdef>librdf_node * <parameter>target</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arc</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> arc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> target
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the model for arcs matching the given arc and target
   and returns one <structname>librdf_node</structname> object
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-arc">librdf_model_get_arc</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_arc</refname>
 <refpurpose>
      return one arc (predicate) of an arc in an RDF graph given source (subject) and target (object)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_model_get_arc </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>source</parameter></paramdef>
   <paramdef>librdf_node * <parameter>target</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> target
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the model for arcs matching the given source and target
   and returns one <structname>librdf_node</structname> object
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-target">librdf_model_get_target</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_target</refname>
 <refpurpose>
      return one target (object) of an arc in an RDF graph given source (subject) and arc (predicate)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_model_get_target </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>source</parameter></paramdef>
   <paramdef>librdf_node * <parameter>arc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arc</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> arc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the model for targets matching the given source and arc
   and returns one <structname>librdf_node</structname> object
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-add-submodel">librdf_model_add_submodel</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_add_submodel</refname>
 <refpurpose>
      add a sub-model to the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_add_submodel </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_model* <parameter>sub_model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sub_model</parameter></term>
   <listitem>
    <para>
      the sub model to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>FIXME</title>
 <para>
    Not tested
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-remove-submodel">librdf_model_remove_submodel</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_remove_submodel</refname>
 <refpurpose>
      remove a sub-model from the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_remove_submodel </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_model* <parameter>sub_model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sub_model</parameter></term>
   <listitem>
    <para>
      the sub model to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>FIXME</title>
 <para>
    Not tested
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-arcs-in">librdf_model_get_arcs_in</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_arcs_in</refname>
 <refpurpose>
      return the properties pointing to the given resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_model_get_arcs_in </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-get-arcs-out">librdf_model_get_arcs_out</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_get_arcs_out</refname>
 <refpurpose>
      return the properties pointing from the given resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_model_get_arcs_out </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-has-arc-in">librdf_model_has_arc_in</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_has_arc_in</refname>
 <refpurpose>
      check if a node has a given property pointing to it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_has_arc_in </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
   <paramdef>librdf_node * <parameter>property</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> property node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if arc property does point to the resource node
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-has-arc-out">librdf_model_has_arc_out</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_has_arc_out</refname>
 <refpurpose>
      check if a node has a given property pointing from it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_has_arc_out </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
   <paramdef>librdf_node * <parameter>property</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> property node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if arc property does point from the resource node
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-print">librdf_model_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_print</refname>
 <refpurpose>
      print the model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_model_print </function></funcdef>
   <paramdef>librdf_model * <parameter>model</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      the FILE stream to print to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This method is for debugging and the format of the output should
   not be relied on.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-context-add-statement">librdf_model_context_add_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_context_add_statement</refname>
 <refpurpose>
      Add a statement to a model with a context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_context_add_statement </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   It must be a complete statement - all
   of subject, predicate, object parts must be present.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    Non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-context-add-statements">librdf_model_context_add_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_context_add_statements</refname>
 <refpurpose>
      Add statements to a model with a context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_context_add_statements </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
   <paramdef>librdf_stream* <parameter>stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      <structname>librdf_stream</structname> stream object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    Non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-context-remove-statement">librdf_model_context_remove_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_context_remove_statement</refname>
 <refpurpose>
      Remove a statement from a model in a context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_context_remove_statement </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   It must be a complete statement - all of subject, predicate, object
   parts must be present.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    Non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-context-remove-statements">librdf_model_context_remove_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_context_remove_statements</refname>
 <refpurpose>
      Remove statements from a model with the given context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_model_context_remove_statements </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    Non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-context-as-stream">librdf_model_context_as_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_context_as_stream</refname>
 <refpurpose>
      list all statements in a model context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_model_context_as_stream </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-context-serialize">librdf_model_context_serialize</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_context_serialize</refname>
 <refpurpose>
      List all statements in a model context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_model_context_serialize </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   DEPRECATED to reduce confusion with the librdf_serializer class.
   Please use librdf_model_context_as_stream.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-query">librdf_model_query</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_query</refname>
 <refpurpose>
      Run a query against the model returning matching statements
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_model_query </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>librdf_query* <parameter>query</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>query</parameter></term>
   <listitem>
    <para>
      <structname>librdf_query</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Run the given query against the model and return a <structname>librdf_stream</structname> of
   matching <structname>librdf_statement</structname> objects
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of matching statements (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-query-string">librdf_model_query_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_query_string</refname>
 <refpurpose>
      Run a query string against the model returning matching statements
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_model_query_string </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>const char * <parameter>query_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      query language name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      query language URI (or NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>query_string</parameter></term>
   <listitem>
    <para>
      string in query language
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Run the given query against the model and return a <structname>librdf_stream</structname> of
   matching <structname>librdf_statement</structname> objects
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of matching statements (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="model-sync">librdf_model_sync</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_model_sync</refname>
 <refpurpose>
      Synchronise the model to the storage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_model_sync </function></funcdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="statement">
<?dbhtml filename='statement.html'>
<title>RDF Statement / Assertion / Triple</title>
<para>
This module provides the RDF statement functionality, and contains
three parts: resource, predicate and object which are all
nodes provided by the librdf_node class.  Statements can be added /
removed from models.
</para>
<para>
Statements have at least one rdf:type and are always of rdf:type rdf:resource.
They can be present in the model and/or
<emphasis>reified</emphasis> in which they are quoted or talked about
by other statements.
</para>
<sect1>
<title>RDF Statement Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="init-statement">librdf_init_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_statement</refname>
 <refpurpose>
   Initialise the librdf_statement module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_statement </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-statement">librdf_finish_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_statement</refname>
 <refpurpose>
      Terminate the librdf_statement module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_statement </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-statement">librdf_new_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_statement</refname>
 <refpurpose>
      Constructor - create a new empty librdf_statement
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_statement* <function>librdf_new_statement </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_statement</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-statement-from-statement">librdf_new_statement_from_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_statement_from_statement</refname>
 <refpurpose>
      Copy constructor - create a new librdf_statement from an existing librdf_statement
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_statement* <function>librdf_new_statement_from_statement </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_statement</structname> with copy or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-statement-from-nodes">librdf_new_statement_from_nodes</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_statement_from_nodes</refname>
 <refpurpose>
      Constructor - create a new librdf_statement from existing librdf_node objects
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_statement* <function>librdf_new_statement_from_nodes </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_node* <parameter>subject</parameter></paramdef>
   <paramdef>librdf_node* <parameter>predicate</parameter></paramdef>
   <paramdef>librdf_node* <parameter>object</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subject</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>predicate</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>object</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The node objects become owned by the new statement (or freed on error).
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_statement</structname> with copy or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-init">librdf_statement_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_init</refname>
 <refpurpose>
      initialise a statically declared librdf_statement
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_statement_init </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This MUST be called on a statically declared librdf_statement
   to initialise it properly.  It is the responsibility of the
   user of the statically allocated librdf_statement to deal
   with deallocation of any statement parts (subject, predicate, object).
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_statement</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-clear">librdf_statement_clear</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_clear</refname>
 <refpurpose>
      empty a librdf_statement of nodes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_statement_clear </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-statement">librdf_free_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_statement</refname>
 <refpurpose>
      Destructor - destroy a librdf_statement
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_statement </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-get-subject">librdf_statement_get_subject</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_get_subject</refname>
 <refpurpose>
      Get the statement subject
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_statement_get_subject </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a pointer to the <structname>librdf_node</structname> of the statement subject - 
   NOTE this is a shared copy and must be copied if used by the caller.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-set-subject">librdf_statement_set_subject</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_set_subject</refname>
 <refpurpose>
      Set the statement subject
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_statement_set_subject </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of subject
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The subject passed in becomes owned by
   the statement object and must not be used by the caller after this call.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-get-predicate">librdf_statement_get_predicate</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_get_predicate</refname>
 <refpurpose>
      Get the statement predicate
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_statement_get_predicate </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a pointer to the <structname>librdf_node</structname> of the statement predicate - 
   NOTE this is a shared copy and must be copied if used by the caller.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-set-predicate">librdf_statement_set_predicate</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_set_predicate</refname>
 <refpurpose>
      Set the statement predicate
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_statement_set_predicate </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of predicate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The predicate passed in becomes owned by
   the statement object and must not be used by the caller after this call.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-get-object">librdf_statement_get_object</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_get_object</refname>
 <refpurpose>
      Get the statement object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_statement_get_object </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a pointer to the <structname>librdf_node</structname> of the statement object - 
   NOTE this is a shared copy and must be copied if used by the caller.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-set-object">librdf_statement_set_object</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_set_object</refname>
 <refpurpose>
      Set the statement object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_statement_set_object </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> of object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The object passed in becomes owned by
   the statement object and must not be used by the caller after this call.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-is-complete">librdf_statement_is_complete</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_is_complete</refname>
 <refpurpose>
      Check if statement has all subject, predicate, object fields present
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_statement_is_complete </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if the statement has subject, predicate and object.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-to-string">librdf_statement_to_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_to_string</refname>
 <refpurpose>
      Format the librdf_statement as a string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>librdf_statement_to_string </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Formats the statement as a newly allocate string that must be freed by
   the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the string or NULL on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-print">librdf_statement_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_print</refname>
 <refpurpose>
      pretty print the statement to a file descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_statement_print </function></funcdef>
   <paramdef>librdf_statement * <parameter>statement</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      file handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This method is for debugging and the format of the output should
   not be relied on.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-equals">librdf_statement_equals</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_equals</refname>
 <refpurpose>
      Check if two statements are equal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_statement_equals </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement1</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement1</parameter></term>
   <listitem>
    <para>
      first <structname>librdf_statement</structname>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement2</parameter></term>
   <listitem>
    <para>
      second <structname>librdf_statement</structname>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if statements are equal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-match">librdf_statement_match</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_match</refname>
 <refpurpose>
      Match a statement against a 'partial' statement
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_statement_match </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>partial_statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      statement
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>partial_statement</parameter></term>
   <listitem>
    <para>
      statement with possible empty parts
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   A partial statement is where some parts of the statement -
   subject, predicate or object can be empty (NULL).
   Empty parts match against any value, parts with values
   must match exactly.  Node matching is done via <function>librdf_node_equals</function>
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on match
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-encode">librdf_statement_encode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_encode</refname>
 <refpurpose>
      Serialise a statement into a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>librdf_statement_encode </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement to serialise
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Encodes the given statement in the buffer, which must be of sufficient
   size.  If buffer is NULL, no work is done but the size of buffer
   required is returned.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the number of bytes written or 0 on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-encode-parts">librdf_statement_encode_parts</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_encode_parts</refname>
 <refpurpose>
      Serialise parts of a statement into a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>librdf_statement_encode_parts </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context_node</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
   <paramdef>int <parameter>fields</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      statement to serialise
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fields</parameter></term>
   <listitem>
    <para>
      fields to encode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Encodes the given statement in the buffer, which must be of sufficient
   size.  If buffer is NULL, no work is done but the size of buffer
   required is returned.
   </para><para>

   The fields values are or-ed combinations of:
   LIBRDF_STATEMENT_SUBJECT LIBRDF_STATEMENT_PREDICATE
   LIBRDF_STATEMENT_OBJECT
   or LIBRDF_STATEMENT_ALL for subject,prdicate,object fields
   </para><para>

   If context_node is given, it is encoded also
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the number of bytes written or 0 on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-decode">librdf_statement_decode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_decode</refname>
 <refpurpose>
      Decodes a statement from a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>librdf_statement_decode </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement to deserialise into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Decodes the serialised statement (as created by <function>librdf_statement_encode</function> )
   from the given buffer.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    number of bytes used or 0 on failure (bad encoding, allocation failure)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="statement-decode-parts">librdf_statement_decode_parts</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_statement_decode_parts</refname>
 <refpurpose>
      Decodes a statement + context node from a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>librdf_statement_decode_parts </function></funcdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
   <paramdef>librdf_node** <parameter>context_node</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement to deserialise into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
      pointer to <structname>librdf_node</structname> context_node to deserialise into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Decodes the serialised statement (as created by <function>librdf_statement_encode</function> )
   from the given buffer.  If a context node is found and context_node is
   not NULL, a pointer to the new <structname>librdf_node</structname> is stored in *context_node.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    number of bytes used or 0 on failure (bad encoding, allocation failure)
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="node">
<?dbhtml filename='node.html'>
<title>RDF Resource / Predicate / Literal</title>
<para>
This module provides the elements of the RDF statement - resource (or subject o source), predicate (or property or arc) and object (or target): resource / literal.  These make up parts of the statement object.
</para>

<para>
Nodes have two types - resource (used for subject, predicate and
object) and literal (only used for object).  Resources have URIs,
Literals have string content plus optional XML Language
and a flag if the content is XML which is used for
supporting XML Literals.
</para>
<sect1>
<title>RDF Node Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="init-node">librdf_init_node</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_node</refname>
 <refpurpose>
   Initialise the node module.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_node </function></funcdef>
   <paramdef>librdf_world* <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-node">librdf_finish_node</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_node</refname>
 <refpurpose>
      Terminate the librdf_node module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_node </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node">librdf_new_node</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node</refname>
 <refpurpose>
      Constructor - create a new librdf_node object with a private identifier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Calls librdf_new_node_from_blank_identifier(world, NULL) to
   construct a new redland blank node identifier and make a
   new librdf_node object for it.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-uri-string">librdf_new_node_from_uri_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_uri_string</refname>
 <refpurpose>
      Constructor - create a new librdf_node object from a URI string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_uri_string </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>uri_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri_string</parameter></term>
   <listitem>
    <para>
      string representing a URI
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The URI can be NULL, and can be set later.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-uri">librdf_new_node_from_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_uri</refname>
 <refpurpose>
      Constructor - create a new resource librdf_node object with a given URI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_uri </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>rdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-uri-local-name">librdf_new_node_from_uri_local_name</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_uri_local_name</refname>
 <refpurpose>
      Constructor - create a new resource librdf_node object with a given URI and local name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_uri_local_name </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>const char * <parameter>local_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>rdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>local_name</parameter></term>
   <listitem>
    <para>
      local name to append to URI
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-normalised-uri-string">librdf_new_node_from_normalised_uri_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_normalised_uri_string</refname>
 <refpurpose>
      Constructor - create a new librdf_node object from a URI string normalised to a new base URI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_normalised_uri_string </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>uri_string</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>source_uri</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri_string</parameter></term>
   <listitem>
    <para>
      string representing a URI
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source_uri</parameter></term>
   <listitem>
    <para>
      source URI
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      base URI
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-literal">librdf_new_node_from_literal</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_literal</refname>
 <refpurpose>
       Constructor - create a new literal librdf_node object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_literal </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
   <paramdef>const char * <parameter>xml_language</parameter></paramdef>
   <paramdef>int <parameter>is_wf_xml</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
      literal string value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xml_language</parameter></term>
   <listitem>
    <para>
      literal XML language (or NULL, empty string)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_wf_xml</parameter></term>
   <listitem>
    <para>
      non 0 if literal is XML
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   0.9.12: xml_space argument deleted
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-typed-literal">librdf_new_node_from_typed_literal</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_typed_literal</refname>
 <refpurpose>
       Constructor - create a new typed literal librdf_node object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_typed_literal </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>value</parameter></paramdef>
   <paramdef>const char * <parameter>xml_language</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>datatype_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xml_language</parameter></term>
   <listitem>
    <para>
      literal XML language (or NULL, empty string)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>datatype_uri</parameter></term>
   <listitem>
    <para>
      URI of typed literal datatype or NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-blank-identifier">librdf_new_node_from_blank_identifier</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_blank_identifier</refname>
 <refpurpose>
       Constructor - create a new literal librdf_node object from a blank node identifier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_blank_identifier </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>identifier</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>identifier</parameter></term>
   <listitem>
    <para>
      blank node identifier or NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If no identifier string is given, creates a new internal identifier
   and assigns it.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-node-from-node">librdf_new_node_from_node</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_node_from_node</refname>
 <refpurpose>
      Copy constructor - create a new librdf_node object from an existing librdf_node object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_new_node_from_node </function></funcdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_node</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-init">librdf_node_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_init</refname>
 <refpurpose>
      initialise a statically declared librdf_node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_node_init </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_node</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-node">librdf_free_node</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_node</refname>
 <refpurpose>
      Destructor - destroy an librdf_node object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_node </function></funcdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-uri">librdf_node_get_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_uri</refname>
 <refpurpose>
      Get the URI for a node object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_node_get_uri </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a pointer to the URI object held by the node, it must be
   copied if it is wanted to be used by the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    URI object or NULL if node has no URI.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-type">librdf_node_get_type</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_type</refname>
 <refpurpose>
      Get the type of the node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node_type <function>librdf_node_get_type </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the node type
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-literal-value">librdf_node_get_literal_value</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_literal_value</refname>
 <refpurpose>
      Get the string literal value of the node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_node_get_literal_value </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a pointer to the literal value held by the node, it must be
   copied if it is wanted to be used by the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the literal string or NULL if node is not a literal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-literal-value-as-counted-string">librdf_node_get_literal_value_as_counted_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_literal_value_as_counted_string</refname>
 <refpurpose>
      Get the string literal value of the node as a counted string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_node_get_literal_value_as_counted_string </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
   <paramdef>size_t * <parameter>len_p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len_p</parameter></term>
   <listitem>
    <para>
      pointer to location to store length (or NULL)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a pointer to the literal value held by the node, it must be
   copied if it is wanted to be used by the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the literal string or NULL if node is not a literal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-literal-value-as-latin1">librdf_node_get_literal_value_as_latin1</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_literal_value_as_latin1</refname>
 <refpurpose>
      Get the string literal value of the node as ISO Latin-1
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_node_get_literal_value_as_latin1 </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a newly allocated string containing the conversion of the
   UTF-8 literal value held by the node.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the literal string or NULL if node is not a literal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-literal-value-language">librdf_node_get_literal_value_language</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_literal_value_language</refname>
 <refpurpose>
      Get the XML language of the node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_node_get_literal_value_language </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a pointer to the literal language value held by the node, it must
   be copied if it is wanted to be used by the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the XML language string or NULL if node is not a literal
   or there is no XML language defined.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-literal-value-is-wf-xml">librdf_node_get_literal_value_is_wf_xml</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_literal_value_is_wf_xml</refname>
 <refpurpose>
      Get the XML well-formness property of the node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_node_get_literal_value_is_wf_xml </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    0 if the XML literal is NOT well formed XML content, or the node is not a literal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-literal-value-datatype-uri">librdf_node_get_literal_value_datatype_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_literal_value_datatype_uri</refname>
 <refpurpose>
      Get the typed literal datatype URI of the literal node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_node_get_literal_value_datatype_uri </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    shared URI of the datatyped literal or NULL if the node is not a literal, or has no datatype URI
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-li-ordinal">librdf_node_get_li_ordinal</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_li_ordinal</refname>
 <refpurpose>
      Get the node li object ordinal value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_node_get_li_ordinal </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the li ordinal value
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-blank-identifier">librdf_node_get_blank_identifier</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_blank_identifier</refname>
 <refpurpose>
      Get the blank node identifier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>librdf_node_get_blank_identifier </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the identifier value
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-is-resource">librdf_node_is_resource</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_is_resource</refname>
 <refpurpose>
       Check node is a resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_node_is_resource </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non-zero if the node is a resource (URI)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-is-literal">librdf_node_is_literal</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_is_literal</refname>
 <refpurpose>
       Check node is a literal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_node_is_literal </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non-zero if the node is a literal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-is-blank">librdf_node_is_blank</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_is_blank</refname>
 <refpurpose>
       Check node is a blank nodeID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_node_is_blank </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non-zero if the node is a blank nodeID
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-to-string">librdf_node_to_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_to_string</refname>
 <refpurpose>
      Format the node as a string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_node_to_string </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Note a new string is allocated which must be freed by the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a string value representing the node or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-to-counted-string">librdf_node_to_counted_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_to_counted_string</refname>
 <refpurpose>
      Format the node as a counted string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_node_to_counted_string </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
   <paramdef>size_t* <parameter>len_p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len_p</parameter></term>
   <listitem>
    <para>
      pointer to location to store length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Note a new string is allocated which must be freed by the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a string value representing the node or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-print">librdf_node_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_print</refname>
 <refpurpose>
      pretty print the node to a file descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_node_print </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      file handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This method is for debugging and the format of the output should
   not be relied on.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-get-digest">librdf_node_get_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_get_digest</refname>
 <refpurpose>
      Get a digest representing a librdf_node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_digest* <function>librdf_node_get_digest </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   A new digest object is created which must be freed by the caller.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_digest</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-equals">librdf_node_equals</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_equals</refname>
 <refpurpose>
      Compare two librdf_node objects for equality
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_node_equals </function></funcdef>
   <paramdef>librdf_node* <parameter>first_node</parameter></paramdef>
   <paramdef>librdf_node* <parameter>second_node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>first_node</parameter></term>
   <listitem>
    <para>
      first <structname>librdf_node</structname> node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>second_node</parameter></term>
   <listitem>
    <para>
      second <structname>librdf_node</structname> node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Note - for literal nodes, XML language, XML space and well-formness are 
   presently ignored in the comparison.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if nodes are equal.  0 if not-equal or failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-encode">librdf_node_encode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_encode</refname>
 <refpurpose>
      Serialise a node into a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>librdf_node_encode </function></funcdef>
   <paramdef>librdf_node* <parameter>node</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      the node to serialise
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Encodes the given node in the buffer, which must be of sufficient
   size.  If buffer is NULL, no work is done but the size of buffer
   required is returned.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the number of bytes written or 0 on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-decode">librdf_node_decode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_decode</refname>
 <refpurpose>
      Deserialise a node from a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_node* <function>librdf_node_decode </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>size_t* <parameter>size_p</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      librdf_world
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size_p</parameter></term>
   <listitem>
    <para>
      pointer to bytes used or NULL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Decodes the serialised node (as created by <function>librdf_node_encode</function> )
   from the given buffer.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new node or NULL on failure (bad encoding, allocation failure)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="node-static-iterator-create">librdf_node_static_iterator_create</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_node_static_iterator_create</refname>
 <refpurpose>
      Create an iterator over an array of nodes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_node_static_iterator_create </function></funcdef>
   <paramdef>librdf_node** <parameter>nodes</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nodes</parameter></term>
   <listitem>
    <para>
      static array of <structname>librdf_node</structname> objects
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      size of array
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This creates an iterator for an existing static array of librdf_node
   objects.  It is mostly intended for testing iterator code.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a <structname>librdf_iterator</structname> serialization of the nodes or NULL on failure
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="parser">
<?dbhtml filename='parser.html'>
<title>RDF Parsers</title>
<para>
These modules parse RDF/XML syntax and construct models, maybe via
streams of statements.  At present Redland does not have a built in
RDF/XML parser and can be used without one.
</para>
<sect1>
<title>RDF Parser Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="parser-register-factory">librdf_parser_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_register_factory</refname>
 <refpurpose>
   Register a parser factory 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_parser_register_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const char * <parameter>mime_type</parameter></paramdef>
   <paramdef>const char * <parameter>uri_string</parameter></paramdef>
   <paramdef>void (*<parameter>factory</parameter>)
     <funcparams>librdf_parser_factory*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the name of the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mime_type</parameter></term>
   <listitem>
    <para>
      MIME type of the syntax (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri_string</parameter></term>
   <listitem>
    <para>
      URI of the syntax (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      function to be called to register the factor parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="get-parser-factory">librdf_get_parser_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_get_parser_factory</refname>
 <refpurpose>
      Get a parser factory by name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_parser_factory* <function>librdf_get_parser_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const char * <parameter>mime_type</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>type_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the name of the factory (NULL or empty string if don't care)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mime_type</parameter></term>
   <listitem>
    <para>
      the MIME type of the syntax (NULL or empty if don't care)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type_uri</parameter></term>
   <listitem>
    <para>
      URI of syntax (NULL if not used)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If all fields are NULL, this means any parser supporting
   MIME Type <quote>application/rdf+xml</quote>
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the factory or NULL if not found
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-parser">librdf_new_parser</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_parser</refname>
 <refpurpose>
      Constructor - create a new librdf_parser object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_parser* <function>librdf_new_parser </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const char * <parameter>mime_type</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>type_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the parser factory name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mime_type</parameter></term>
   <listitem>
    <para>
      the MIME type of the syntax (NULL if not used)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type_uri</parameter></term>
   <listitem>
    <para>
      URI of syntax (NULL if not used)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If all fields are NULL, this means any parser supporting
   MIME Type <quote>application/rdf+xml</quote>
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_parser</structname> object or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-parser-from-factory">librdf_new_parser_from_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_parser_from_factory</refname>
 <refpurpose>
      Constructor - create a new librdf_parser object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_parser* <function>librdf_new_parser_from_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_parser_factory * <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      the parser factory to use to create this parser
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_parser</structname> object or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-parser">librdf_free_parser</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_parser</refname>
 <refpurpose>
      Destructor - destroys a librdf_parser object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_parser </function></funcdef>
   <paramdef>librdf_parser * <parameter>parser</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-parse-as-stream">librdf_parser_parse_as_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_parse_as_stream</refname>
 <refpurpose>
      Parse a URI to a librdf_stream of statements
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_parser_parse_as_stream </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      the URI to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      the base URI to use (or NULL if the same)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-parse-into-model">librdf_parser_parse_into_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_parse_into_model</refname>
 <refpurpose>
      Parse a URI of content into an librdf_model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_parse_into_model </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      the URI to read the content
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      the base URI to use (or NULL if the same)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-parse-string-as-stream">librdf_parser_parse_string_as_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_parse_string_as_stream</refname>
 <refpurpose>
      Parse a string of content to a librdf_stream of statements
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_parser_parse_string_as_stream </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
      the string to parse
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      the base URI to use (or NULL if the same)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-parse-string-into-model">librdf_parser_parse_string_into_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_parse_string_into_model</refname>
 <refpurpose>
      Parse a string of content into an librdf_model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_parse_string_into_model </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      the base URI to use (or NULL if the same)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the model to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="init-parser">librdf_init_parser</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_parser</refname>
 <refpurpose>
      Initialise the librdf_parser class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_parser </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-parser">librdf_finish_parser</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_parser</refname>
 <refpurpose>
      Terminate the librdf_parser class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_parser </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-set-error">librdf_parser_set_error</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_set_error</refname>
 <refpurpose>
      Set the parser error handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_parser_set_error </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>void * <parameter>user_data</parameter></paramdef>
   <paramdef>void (*<parameter>error_fn</parameter>)
     <funcparams>void *user_data, const char *msg, ...</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_data</parameter></term>
   <listitem>
    <para>
      user data to pass to function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>error_fn</parameter></term>
   <listitem>
    <para>
      pointer to the function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function will receive callbacks when the parser fails.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-set-warning">librdf_parser_set_warning</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_set_warning</refname>
 <refpurpose>
      Set the parser warning handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_parser_set_warning </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>void * <parameter>user_data</parameter></paramdef>
   <paramdef>void (*<parameter>warning_fn</parameter>)
     <funcparams>void *user_data, const char *msg, ...</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_data</parameter></term>
   <listitem>
    <para>
      user data to pass to function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>warning_fn</parameter></term>
   <listitem>
    <para>
      pointer to the function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function will receive callbacks when the parser gives a warning.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-get-feature">librdf_parser_get_feature</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_get_feature</refname>
 <refpurpose>
      Get the value of a parser feature
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>librdf_parser_get_feature </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>feature</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      parser object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>feature</parameter></term>
   <listitem>
    <para>
      URI of feature
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the value of the feature or NULL if no such feature
   exists or the value is empty.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-set-feature">librdf_parser_set_feature</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_set_feature</refname>
 <refpurpose>
      Set the value of a parser feature
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_set_feature </function></funcdef>
   <paramdef>librdf_parser* <parameter>parser</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>feature</parameter></paramdef>
   <paramdef>const char * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      parser object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>feature</parameter></term>
   <listitem>
    <para>
      URI of feature
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      value to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure (negative if no such feature)
 </para>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>Raptor RDF Parser Implementation Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-init">librdf_parser_raptor_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_init</refname>
 <refpurpose>
   Initialise the raptor RDF parser
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_raptor_init </function></funcdef>
   <paramdef>librdf_parser * <parameter>parser</parameter></paramdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parser</parameter></term>
   <listitem>
    <para>
      the parser
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-parse-file-as-stream">librdf_parser_raptor_parse_file_as_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_parse_file_as_stream</refname>
 <refpurpose>
      Retrieve the RDF/XML content at URI and parse it into a librdf_stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_parser_raptor_parse_file_as_stream </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      parser context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of RDF/XML content source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of the content location or NULL if the same
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-parse-as-stream-common">librdf_parser_raptor_parse_as_stream_common</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_parse_as_stream_common</refname>
 <refpurpose>
      Retrieve the content at URI/string and parse it into a librdf_stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_parser_raptor_parse_as_stream_common </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      parser context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of ontent source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
      or content string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of the content location or NULL if the same
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Only one of uri or string may be given
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-parse-uri-as-stream">librdf_parser_raptor_parse_uri_as_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_parse_uri_as_stream</refname>
 <refpurpose>
      Retrieve the content at URI and parse it into a librdf_stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_parser_raptor_parse_uri_as_stream </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      parser context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of content source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of the content location or NULL if the same
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-parse-string-as-stream">librdf_parser_raptor_parse_string_as_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_parse_string_as_stream</refname>
 <refpurpose>
      Parse the content in a string and return a librdf_stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_parser_raptor_parse_string_as_stream </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      parser context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
      string content to parse
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of the content location or NULL if the same
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-parse-into-model-common">librdf_parser_raptor_parse_into_model_common</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_parse_into_model_common</refname>
 <refpurpose>
      Retrieve the RDF/XML content at URI and store it into a librdf_model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_raptor_parse_into_model_common </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      parser context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of RDF/XML content source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of the content location
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> of model
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Retrieves all statements and stores them in the given model.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-parse-uri-into-model">librdf_parser_raptor_parse_uri_into_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_parse_uri_into_model</refname>
 <refpurpose>
      Retrieve the RDF/XML content at URI and store it into a librdf_model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_raptor_parse_uri_into_model </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      parser context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of RDF/XML content source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of the content location
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> of model
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Retrieves all statements and stores them in the given model.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-parse-string-into-model">librdf_parser_raptor_parse_string_into_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_parse_string_into_model</refname>
 <refpurpose>
      Parse the RDF/XML content in a string and store it into a librdf_model
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_raptor_parse_string_into_model </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>base_uri</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      parser context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
      RDF/XML source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> URI of the content location
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      <structname>librdf_model</structname> of model
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Stores the statements found parsing string and stores in the given model.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-serialise-end-of-stream">librdf_parser_raptor_serialise_end_of_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_serialise_end_of_stream</refname>
 <refpurpose>
      Check for the end of the stream of statements from the raptor RDF parser
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_raptor_serialise_end_of_stream </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      the context passed in by <structname>librdf_stream</structname>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 at end of stream
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-serialise-next-statement">librdf_parser_raptor_serialise_next_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_serialise_next_statement</refname>
 <refpurpose>
      Move to the next librdf_statement in the stream of statements from the raptor RDF parse
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_parser_raptor_serialise_next_statement </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      the context passed in by <structname>librdf_stream</structname>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 at end of stream
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-serialise-get-statement">librdf_parser_raptor_serialise_get_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_serialise_get_statement</refname>
 <refpurpose>
      Get the current librdf_statement from the stream of statements from the raptor RDF parse
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_parser_raptor_serialise_get_statement </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      the context passed in by <structname>librdf_stream</structname>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_statement</structname> or NULL on error or if no statements found.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-serialise-finished">librdf_parser_raptor_serialise_finished</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_serialise_finished</refname>
 <refpurpose>
      Finish the serialisation of the statement stream from the raptor RDF parse
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_parser_raptor_serialise_finished </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      the context passed in by <structname>librdf_stream</structname>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-register-factory">librdf_parser_raptor_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_register_factory</refname>
 <refpurpose>
      Register the raptor RDF parser with the RDF parser factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_parser_raptor_register_factory </function></funcdef>
   <paramdef>librdf_parser_factory * <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-constructor">librdf_parser_raptor_constructor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_constructor</refname>
 <refpurpose>
      Initialise the raptor RDF parser module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_parser_raptor_constructor </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="parser-raptor-destructor">librdf_parser_raptor_destructor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_parser_raptor_destructor</refname>
 <refpurpose>
      Terminate the raptor RDF parser module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_parser_raptor_destructor </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="digest">
<?dbhtml filename='digest.html'>
<title>Content Digests</title>
<para>
This module provides digests, which are algorithms that operate over
arrays of octets / bytes producing a cryptographically strong digest
that can be used to represent the content.  Digests functions have
different levels of strength.  Digests can be used to generating keys
for hashes and identifiers based on content.
</para>
<sect1>
<title>Digest Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="digest-register-factory">librdf_digest_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_register_factory</refname>
 <refpurpose>
   Register a hash factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_digest_register_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>void (*<parameter>factory</parameter>)
     <funcparams>librdf_digest_factory*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the name of the hash
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      function to be called to register the factory parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="get-digest-factory">librdf_get_digest_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_get_digest_factory</refname>
 <refpurpose>
      get a digest factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_digest_factory* <function>librdf_get_digest_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the name of the factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the factory or NULL if not found
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-digest">librdf_new_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_digest</refname>
 <refpurpose>
      Constructor - create a new librdf_digest object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_digest* <function>librdf_new_digest </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the digest name to use to create this digest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_digest</structname> object or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-digest-from-factory">librdf_new_digest_from_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_digest_from_factory</refname>
 <refpurpose>
      Constructor - create a new librdf_digest object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_digest* <function>librdf_new_digest_from_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_digest_factory * <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      the digest factory to use to create this digest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_digest</structname> object or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-digest">librdf_free_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_digest</refname>
 <refpurpose>
      Destructor- destroy a librdf_digest object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_digest </function></funcdef>
   <paramdef>librdf_digest * <parameter>digest</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest</parameter></term>
   <listitem>
    <para>
      the digest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="digest-init">librdf_digest_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_init</refname>
 <refpurpose>
      (Re)initialise the librdf_digest object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_digest_init </function></funcdef>
   <paramdef>librdf_digest* <parameter>digest</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest</parameter></term>
   <listitem>
    <para>
      the digest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="digest-update">librdf_digest_update</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_update</refname>
 <refpurpose>
      Add more data to the librdf_digest object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_digest_update </function></funcdef>
   <paramdef>librdf_digest* <parameter>digest</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest</parameter></term>
   <listitem>
    <para>
      the digest
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
      the data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      the length of the data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="digest-final">librdf_digest_final</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_final</refname>
 <refpurpose>
      Finish the digesting of data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_digest_final </function></funcdef>
   <paramdef>librdf_digest* <parameter>digest</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest</parameter></term>
   <listitem>
    <para>
      the digest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The digest can now be returned via <function>librdf_digest_get_digest</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="digest-get-digest">librdf_digest_get_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_get_digest</refname>
 <refpurpose>
      Get the calculated digested value.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_digest_get_digest </function></funcdef>
   <paramdef>librdf_digest* <parameter>digest</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest</parameter></term>
   <listitem>
    <para>
      the digest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    pointer to the memory containing the digest.  It will
   be digest_factory-&gt;digest_length bytes in length.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="digest-to-string">librdf_digest_to_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_to_string</refname>
 <refpurpose>
      Get a string representation of the digest object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>librdf_digest_to_string </function></funcdef>
   <paramdef>librdf_digest* <parameter>digest</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest</parameter></term>
   <listitem>
    <para>
      the digest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a newly allocated string that represents the digest.
   This must be released by the caller using <function>free</function> 
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="digest-print">librdf_digest_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_print</refname>
 <refpurpose>
      Print the digest to a FILE handle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_digest_print </function></funcdef>
   <paramdef>librdf_digest* <parameter>digest</parameter></paramdef>
   <paramdef>FILE* <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>digest</parameter></term>
   <listitem>
    <para>
      the digest
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      file handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="init-digest">librdf_init_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_digest</refname>
 <refpurpose>
      Initialise the librdf_digest class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_digest </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-digest">librdf_finish_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_digest</refname>
 <refpurpose>
      Terminate the librdf_digest class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_digest </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>OpenSSL Digests Implementation</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="digest-openssl-constructor">librdf_digest_openssl_constructor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_openssl_constructor</refname>
 <refpurpose>
   Initialise the OpenSSL digest module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_digest_openssl_constructor </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>Local MD5 Digest Implementation</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="digest-md5-constructor">librdf_digest_md5_constructor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_digest_md5_constructor</refname>
 <refpurpose>
   Initialise the MD5 digest factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_digest_md5_constructor </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="hash">
<?dbhtml filename='hash.html'>
<title>Hashes</title>
<para>
A hash in this library is a bag of key/value pairs (with duplicates allowed)
indexed and manipulated by the key.  The hashes can be stored in
memory or with persistant storage.
</para>
<sect1>
<title>Hash Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="init-hash">librdf_init_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_hash</refname>
 <refpurpose>
   Initialise the librdf_hash module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_hash </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Initialises and registers all
   compiled hash modules.  Must be called before using any of the hash
   factory functions such as <function>librdf_get_hash_factory</function>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-hash">librdf_finish_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_hash</refname>
 <refpurpose>
      Terminate the librdf_hash module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_hash </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-hash-datum">librdf_new_hash_datum</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_hash_datum</refname>
 <refpurpose>
      Constructor - Create a new hash datum object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash_datum* <function>librdf_new_hash_datum </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      data to store
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      size of data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    New <structname>librdf_hash_datum</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-hash-datum">librdf_free_hash_datum</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_hash_datum</refname>
 <refpurpose>
      Destructor - destroy a hash datum object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_hash_datum </function></funcdef>
   <paramdef>librdf_hash_datum * <parameter>datum</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>datum</parameter></term>
   <listitem>
    <para>
      hash datum object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-register-factory">librdf_hash_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_register_factory</refname>
 <refpurpose>
      Register a hash factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_register_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>void (*<parameter>factory</parameter>)
     <funcparams>librdf_hash_factory*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the hash factory name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      pointer to function to call to register the factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="get-hash-factory">librdf_get_hash_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_get_hash_factory</refname>
 <refpurpose>
      Get a hash factory by name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash_factory* <function>librdf_get_hash_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the factory name or NULL for the default factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>FIXME</title>
 <para>
    several bits of code assume the default hash factory is
   in memory.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the factory object or NULL if there is no such factory
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-hash">librdf_new_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_hash</refname>
 <refpurpose>
       Constructor - create a new librdf_hash object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash* <function>librdf_new_hash </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>char* <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      factory name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_hash</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-hash-from-factory">librdf_new_hash_from_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_hash_from_factory</refname>
 <refpurpose>
       Constructor - create a new librdf_hash object from a factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash* <function>librdf_new_hash_from_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_hash_factory* <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      the factory to use to construct the hash
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_hash</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-hash-from-hash">librdf_new_hash_from_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_hash_from_hash</refname>
 <refpurpose>
       Copy Constructor - create a new librdf_hash object from an existing one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash* <function>librdf_new_hash_from_hash </function></funcdef>
   <paramdef>librdf_hash* <parameter>old_hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old_hash</parameter></term>
   <listitem>
    <para>
      the hash to use to construct the hash
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_hash</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-hash">librdf_free_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_hash</refname>
 <refpurpose>
      Destructor - destroy a librdf_hash object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_hash </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-open">librdf_hash_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_open</refname>
 <refpurpose>
      Start a hash association 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_open </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>char * <parameter>identifier</parameter></paramdef>
   <paramdef>int <parameter>mode</parameter></paramdef>
   <paramdef>int <parameter>is_writable</parameter></paramdef>
   <paramdef>int <parameter>is_new</parameter></paramdef>
   <paramdef>librdf_hash* <parameter>options</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>identifier</parameter></term>
   <listitem>
    <para>
      indentifier for the hash factory - usually a URI or file name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      hash access mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_writable</parameter></term>
   <listitem>
    <para>
      is hash writable?
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_new</parameter></term>
   <listitem>
    <para>
      is hash new?
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>options</parameter></term>
   <listitem>
    <para>
      a hash of options for the hash factory or NULL if there are none.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This method opens and/or creates a new hash with any resources it
   needs.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-close">librdf_hash_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_close</refname>
 <refpurpose>
      End a hash association
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_close </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-values-count">librdf_hash_values_count</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_values_count</refname>
 <refpurpose>
      Get the number of values in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_values_count </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    integer number of values in the hash or &lt;0 if cannot be determined
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-get">librdf_hash_get</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_get</refname>
 <refpurpose>
      Retrieve one value from hash for a given key as string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_hash_get </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The value returned is from newly allocated memory which the
   caller must free.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the value or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-get-one">librdf_hash_get_one</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_get_one</refname>
 <refpurpose>
      Retrieve one value from hash for a given key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash_datum* <function>librdf_hash_get_one </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The value returned is from newly allocated memory which the
   caller must free.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the value or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-get-all">librdf_hash_get_all</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_get_all</refname>
 <refpurpose>
      Retrieve all values from hash for a given key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_hash_get_all </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      pointer to value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The iterator returns <structname>librdf_hash_datum</structname> objects containing the values.
   These are newly allocated memory which the caller must free.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a <structname>librdf_iterator</structname> serialization of all values or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-get-del">librdf_hash_get_del</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_get_del</refname>
 <refpurpose>
      Retrieve one value from hash for a given key as string and remove all values with that key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_hash_get_del </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The value returned is from newly allocated memory which the
   caller must free.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the value or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-put">librdf_hash_put</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_put</refname>
 <refpurpose>
      Insert key/value pairs into the hash according to flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_put </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key 
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The key and values are copied into the hash; the original pointers
   can be deleted.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-exists">librdf_hash_exists</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_exists</refname>
 <refpurpose>
      Check if a given key/value is in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_exists </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    &gt;0 if the key/value exists in the hash, 0 if not, &lt;0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-delete">librdf_hash_delete</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_delete</refname>
 <refpurpose>
      Delete a key/value pair from the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_delete </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure (including pair not present)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-delete-all">librdf_hash_delete_all</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_delete_all</refname>
 <refpurpose>
      Delete a key and all values from the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_delete_all </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure (including pair not present)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-keys">librdf_hash_keys</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_keys</refname>
 <refpurpose>
      Get the hash keys
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_hash_keys </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The iterator returns <structname>librdf_hash_datum</structname> objects containingvalue returned is from newly allocated memory which the
   caller must free.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_iterator</structname> serialisation of keys or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-sync">librdf_hash_sync</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_sync</refname>
 <refpurpose>
      Flush any cached information to disk if appropriate
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_sync </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-get-fd">librdf_hash_get_fd</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_get_fd</refname>
 <refpurpose>
      Get the file descriptor for the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_get_fd </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This returns the file descriptor if it is file based for
   use with file locking.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the file descriptor
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-print">librdf_hash_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_print</refname>
 <refpurpose>
      pretty print the hash to a file descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_print </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      the hash
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      file handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-print-keys">librdf_hash_print_keys</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_print_keys</refname>
 <refpurpose>
      pretty print the keys to a file descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_print_keys </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      the hash
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      file handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-print-values">librdf_hash_print_values</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_print_values</refname>
 <refpurpose>
      pretty print the values of one key to a file descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_print_values </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>char * <parameter>key_string</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      the hash
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key_string</parameter></term>
   <listitem>
    <para>
      the key as a string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      file handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-from-string">librdf_hash_from_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_from_string</refname>
 <refpurpose>
      Initialise a hash from a string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_from_string </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>const char * <parameter>string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>string</parameter></term>
   <listitem>
    <para>
      hash encoded as a string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>The string format is something like</title>
 <para>
   key1='value1',key2='value2', key3='\'quoted value\''
   </para><para>

   The 's are required and whitespace can appear around the = and ,s
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-from-array-of-strings">librdf_hash_from_array_of_strings</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_from_array_of_strings</refname>
 <refpurpose>
      Initialise a hash from an array of strings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_from_array_of_strings </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>char ** <parameter>array</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      hash object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>array</parameter></term>
   <listitem>
    <para>
      address of the start of the array of char* pointers
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-get-as-boolean">librdf_hash_get_as_boolean</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_get_as_boolean</refname>
 <refpurpose>
      lookup a hash key and decode value as a boolean
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_get_as_boolean </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      <structname>librdf_hash</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key string to look up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    &gt;0 (for true), 0 (for false) or &lt;0 (for key not found or not known boolean value)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-get-as-long">librdf_hash_get_as_long</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_get_as_long</refname>
 <refpurpose>
      lookup a hash key and decode value as a long
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>librdf_hash_get_as_long </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      <structname>librdf_hash</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key string to look up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    &gt;0 (for success), &lt;0 (for key not found or not known boolean value)
 </para>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>Hash Cursor Implementation Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="new-hash-cursor">librdf_new_hash_cursor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_hash_cursor</refname>
 <refpurpose>
   Constructor - Create a new hash cursor over a hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash_cursor* <function>librdf_new_hash_cursor </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      the hash object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_hash_cursor</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-hash-cursor">librdf_free_hash_cursor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_hash_cursor</refname>
 <refpurpose>
      Destructor - destroy a librdf_hash_cursor object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_hash_cursor </function></funcdef>
   <paramdef>librdf_hash_cursor* <parameter>cursor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cursor</parameter></term>
   <listitem>
    <para>
      hash cursor object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
 </para>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>Berkeley DB Hash Implementation Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-create">librdf_hash_bdb_create</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_create</refname>
 <refpurpose>
   Create a BerkeleyDB hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_create </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      <structname>librdf_hash</structname> hash that this implements
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-destroy">librdf_hash_bdb_destroy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_destroy</refname>
 <refpurpose>
      Destroy a BerkeleyDB hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_destroy </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-open">librdf_hash_bdb_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_open</refname>
 <refpurpose>
      Open and maybe create a BerkeleyDB hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_open </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>char * <parameter>identifier</parameter></paramdef>
   <paramdef>int <parameter>mode</parameter></paramdef>
   <paramdef>int <parameter>is_writable</parameter></paramdef>
   <paramdef>int <parameter>is_new</parameter></paramdef>
   <paramdef>librdf_hash* <parameter>options</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>identifier</parameter></term>
   <listitem>
    <para>
      filename to use for BerkeleyDB file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      file creation mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_writable</parameter></term>
   <listitem>
    <para>
      is hash writable?
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_new</parameter></term>
   <listitem>
    <para>
      is hash new?
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>options</parameter></term>
   <listitem>
    <para>
      hash options (currently unused)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-close">librdf_hash_bdb_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_close</refname>
 <refpurpose>
      Close the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_close </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Finish the association between the rdf hash and the BDB file (does
   not delete the file)
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-clone">librdf_hash_bdb_clone</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_clone</refname>
 <refpurpose>
      Clone the BerkeleyDB hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_clone </function></funcdef>
   <paramdef>librdf_hash * <parameter>hash</parameter></paramdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>char * <parameter>new_identifier</parameter></paramdef>
   <paramdef>void * <parameter>old_context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      new <structname>librdf_hash</structname> that this implements
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      new BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_identifier</parameter></term>
   <listitem>
    <para>
      new identifier for this hash
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>old_context</parameter></term>
   <listitem>
    <para>
      old BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Clones the existing Berkeley DB hash into the new one with the
   new identifier.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-values-count">librdf_hash_bdb_values_count</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_values_count</refname>
 <refpurpose>
      Get the number of values in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_values_count </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    number of values in the hash or &lt;0 if not available
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-cursor-init">librdf_hash_bdb_cursor_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_cursor_init</refname>
 <refpurpose>
      Initialise a new bdb cursor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_cursor_init </function></funcdef>
   <paramdef>void * <parameter>cursor_context</parameter></paramdef>
   <paramdef>void * <parameter>hash_context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cursor_context</parameter></term>
   <listitem>
    <para>
      hash cursor context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hash_context</parameter></term>
   <listitem>
    <para>
      hash to operate over
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-cursor-get">librdf_hash_bdb_cursor_get</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_cursor_get</refname>
 <refpurpose>
      Retrieve a hash value for the given key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_cursor_get </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
   <paramdef>unsigned int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash cursor context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      pointer to value to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
      flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-cursor-finish">librdf_hash_bdb_cursor_finish</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_cursor_finish</refname>
 <refpurpose>
      Finish the serialisation of the hash bdb get
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_bdb_cursor_finish </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash cursor context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-put">librdf_hash_bdb_put</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_put</refname>
 <refpurpose>
      Store a key/value pair in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_put </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key to store
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      pointer to value to store
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-exists">librdf_hash_bdb_exists</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_exists</refname>
 <refpurpose>
      Test the existence of a key/value in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_exists </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      pointer to value (optional)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The value can be NULL in which case the check will just be
   for the key.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    &gt;0 if the key/value exists in the hash, 0 if not, &lt;0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-delete-key">librdf_hash_bdb_delete_key</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_delete_key</refname>
 <refpurpose>
      Delete all values for given key from the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_delete_key </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-delete-key-value">librdf_hash_bdb_delete_key_value</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_delete_key_value</refname>
 <refpurpose>
      Delete given key/value from the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_delete_key_value </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-sync">librdf_hash_bdb_sync</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_sync</refname>
 <refpurpose>
      Flush the hash to disk
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_sync </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-get-fd">librdf_hash_bdb_get_fd</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_get_fd</refname>
 <refpurpose>
      Get the file description representing the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_bdb_get_fd </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      BerkeleyDB hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the file descriptor
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-bdb-register-factory">librdf_hash_bdb_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_bdb_register_factory</refname>
 <refpurpose>
      Register the BerkeleyDB hash module with the hash factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_bdb_register_factory </function></funcdef>
   <paramdef>librdf_hash_factory * <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      hash factory prototype
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="init-hash-bdb">librdf_init_hash_bdb</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_hash_bdb</refname>
 <refpurpose>
      Initialise the BerkeleyDB hash module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_hash_bdb </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>In Memory Hash Implementation Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-find-node">librdf_hash_memory_find_node</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_find_node</refname>
 <refpurpose>
   Find the node for the given key or value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_hash_memory_node* <function>librdf_hash_memory_find_node </function></funcdef>
   <paramdef>librdf_hash_memory_context* <parameter>hash</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
   <paramdef>size_t <parameter>key_len</parameter></paramdef>
   <paramdef>int * <parameter>user_bucket</parameter></paramdef>
   <paramdef>librdf_hash_memory_node** <parameter>prev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      the memory hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key_len</parameter></term>
   <listitem>
    <para>
      key string length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_bucket</parameter></term>
   <listitem>
    <para>
      pointer to store bucket
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prev</parameter></term>
   <listitem>
    <para>
      pointer to store previous node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If value is not NULL and value_len is non 0, the value will also be
   compared in the search.
   </para><para>

   If user_bucket is not NULL, the bucket used will be returned.  if
   prev is no NULL, the previous node in the list will be returned.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_hash_memory_node</structname> of content or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-create">librdf_hash_memory_create</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_create</refname>
 <refpurpose>
      Create a new memory hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_create </function></funcdef>
   <paramdef>librdf_hash* <parameter>hash</parameter></paramdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hash</parameter></term>
   <listitem>
    <para>
      <structname>librdf_hash</structname> hash
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash contxt
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-destroy">librdf_hash_memory_destroy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_destroy</refname>
 <refpurpose>
      Destroy a memory hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_destroy </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-open">librdf_hash_memory_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_open</refname>
 <refpurpose>
      Open memory hash with given parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_open </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>char * <parameter>identifier</parameter></paramdef>
   <paramdef>int <parameter>mode</parameter></paramdef>
   <paramdef>int <parameter>is_writable</parameter></paramdef>
   <paramdef>int <parameter>is_new</parameter></paramdef>
   <paramdef>librdf_hash* <parameter>options</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>identifier</parameter></term>
   <listitem>
    <para>
      identifier - not used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      access mode - not used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_writable</parameter></term>
   <listitem>
    <para>
      is hash writable? - not used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_new</parameter></term>
   <listitem>
    <para>
      is hash new? - not used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>options</parameter></term>
   <listitem>
    <para>
      <structname>librdf_hash</structname> of options - not used
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-close">librdf_hash_memory_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_close</refname>
 <refpurpose>
      Close the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_close </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-values-count">librdf_hash_memory_values_count</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_values_count</refname>
 <refpurpose>
      Get the number of values in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_values_count </function></funcdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash cursor context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    number of values in the hash or &lt;0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-cursor-init">librdf_hash_memory_cursor_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_cursor_init</refname>
 <refpurpose>
      Initialise a new hash cursor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_cursor_init </function></funcdef>
   <paramdef>void * <parameter>cursor_context</parameter></paramdef>
   <paramdef>void * <parameter>hash_context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cursor_context</parameter></term>
   <listitem>
    <para>
      hash cursor context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hash_context</parameter></term>
   <listitem>
    <para>
      hash to operate over
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-cursor-get">librdf_hash_memory_cursor_get</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_cursor_get</refname>
 <refpurpose>
      Retrieve a hash value for the given key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_cursor_get </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
   <paramdef>unsigned int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash cursor context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      pointer to value to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
      flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-cursor-finish">librdf_hash_memory_cursor_finish</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_cursor_finish</refname>
 <refpurpose>
      Finish the serialisation of the hash memory get
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_memory_cursor_finish </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      hash memory get iterator context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-put">librdf_hash_memory_put</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_put</refname>
 <refpurpose>
      Store a key/value pair in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_put </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key to store
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      pointer to value to store
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-exists">librdf_hash_memory_exists</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_exists</refname>
 <refpurpose>
      Test the existence of a key in the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_exists </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    &gt;0 if the key/value exists in the hash, 0 if not, &lt;0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-delete-key-value">librdf_hash_memory_delete_key_value</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_delete_key_value</refname>
 <refpurpose>
      Delete a key/value pair from the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_delete_key_value </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key to delete
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      pointer to value to delete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-delete-key">librdf_hash_memory_delete_key</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_delete_key</refname>
 <refpurpose>
      Delete a key and all its values from the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_delete_key </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>librdf_hash_datum * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      pointer to key to delete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-sync">librdf_hash_memory_sync</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_sync</refname>
 <refpurpose>
      Flush the hash to disk
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_sync </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Not used
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    0
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-get-fd">librdf_hash_memory_get_fd</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_get_fd</refname>
 <refpurpose>
      Get the file descriptor representing the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_hash_memory_get_fd </function></funcdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      memory hash context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Not used
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    -1
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="hash-memory-register-factory">librdf_hash_memory_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_hash_memory_register_factory</refname>
 <refpurpose>
      Register the memory hash module with the hash factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_hash_memory_register_factory </function></funcdef>
   <paramdef>librdf_hash_factory * <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      hash factory prototype
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="init-hash-memory">librdf_init_hash_memory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_hash_memory</refname>
 <refpurpose>
      Initialise the memory hash module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_hash_memory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Initialises the memory hash module and sets the default hash load factor.
   </para><para>

   The recommended and current default value is 0.75, i.e. 750/1000.  
   To use the default value (whatever it is) use a value less than 0.
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="query">
<?dbhtml filename='query.html'>
<title>RDF Query</title>
<para>
This module provides query language support for RDF models
either via an adaptor class or direct by persistant storage.
</para>
<sect1>
<title>RDF Query Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="init-query">librdf_init_query</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_query</refname>
 <refpurpose>
   Initialise the librdf_query module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_query </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Initialises and registers all
   compiled query modules.  Must be called before using any of the query
   factory functions such as <function>librdf_get_query_factory</function>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-query">librdf_finish_query</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_query</refname>
 <refpurpose>
      Terminate the librdf_query module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_query </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="query-register-factory">librdf_query_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_query_register_factory</refname>
 <refpurpose>
      Register a query factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_query_register_factory </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>void (*<parameter>factory</parameter>)
     <funcparams>librdf_query_factory*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the query language name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      the query language URI (or NULL if none)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      pointer to function to call to register the factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="get-query-factory">librdf_get_query_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_get_query_factory</refname>
 <refpurpose>
      Get a query factory by name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_query_factory* <function>librdf_get_query_factory </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the factory name or NULL for the default factory
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      the factory URI or NULL for the default factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the factory object or NULL if there is no such factory
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-query">librdf_new_query</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_query</refname>
 <refpurpose>
      Constructor - create a new librdf_query object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_query* <function>librdf_new_query </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>const char * <parameter>query_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the query language name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      the query language URI (or NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>query_string</parameter></term>
   <listitem>
    <para>
      the query string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_query</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-query-from-query">librdf_new_query_from_query</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_query_from_query</refname>
 <refpurpose>
      Copy constructor - create a new librdf_query object from an existing one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_query* <function>librdf_new_query_from_query </function></funcdef>
   <paramdef>librdf_query* <parameter>old_query</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old_query</parameter></term>
   <listitem>
    <para>
      the existing query <structname>librdf_query</structname> to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Should create a new query in the same context as the existing one
   as appropriate.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_query</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-query-from-factory">librdf_new_query_from_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_query_from_factory</refname>
 <refpurpose>
      Constructor - create a new librdf_query object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_query* <function>librdf_new_query_from_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_query_factory* <parameter>factory</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>const char * <parameter>query_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      the factory to use to construct the query
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      query language name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      query language URI (or NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>query_string</parameter></term>
   <listitem>
    <para>
      the query string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_query</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-query">librdf_free_query</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_query</refname>
 <refpurpose>
      Destructor - destroy a librdf_query object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_query </function></funcdef>
   <paramdef>librdf_query* <parameter>query</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>query</parameter></term>
   <listitem>
    <para>
      <structname>librdf_query</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="query-open">librdf_query_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_query_open</refname>
 <refpurpose>
      Start a query
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_query_open </function></funcdef>
   <paramdef>librdf_query* <parameter>query</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>query</parameter></term>
   <listitem>
    <para>
      <structname>librdf_query</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is ended with <function>librdf_query_close</function>
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="query-close">librdf_query_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_query_close</refname>
 <refpurpose>
      End a model / query association
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_query_close </function></funcdef>
   <paramdef>librdf_query* <parameter>query</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>query</parameter></term>
   <listitem>
    <para>
      <structname>librdf_query</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="query-run">librdf_query_run</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_query_run</refname>
 <refpurpose>
      Run the query on a model giving matching statements
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_query_run </function></funcdef>
   <paramdef>librdf_query* <parameter>query</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>query</parameter></term>
   <listitem>
    <para>
      <structname>librdf_query</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      model to operate query on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Runs the query against the (previously registered) model
   and returns a <structname>librdf_stream</structname> of
   matching <structname>librdf_statement</structname> objects.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_stream</structname> of matching statements (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>RDF Query Triples Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="query-triples-init">librdf_query_triples_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_query_triples_init</refname>
 <refpurpose>
   Initialise a triples query from the string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_query_triples_init </function></funcdef>
   <paramdef>librdf_query* <parameter>query</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
   <paramdef>const char* <parameter>query_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>query</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_query</structname>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the query language name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      the query language URI or NULL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>query_string</parameter></term>
   <listitem>
    <para>
      the query string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Parses the query string in the triples form to create an internal
   representation, suitable for use in querying.
 </para>
</refsect1>
<refsect1>
 <title>query     </title>
 <para>
   = subject ' ' predicate ' ' object
 </para>
</refsect1>
<refsect1>
 <title>subject   </title>
 <para>
   = null | uri
 </para>
</refsect1>
<refsect1>
 <title>predicate </title>
 <para>
   = null | uri
 </para>
</refsect1>
<refsect1>
 <title>object    </title>
 <para>
   = null | uri | literal
 </para>
</refsect1>
<refsect1>
 <title>null      </title>
 <para>
    '-'
 </para>
</refsect1>
<refsect1>
 <title>uri       </title>
 <para>
    '[' URI-string ']'
 </para>
</refsect1>
<refsect1>
 <title>literal   </title>
 <para>
    ''' string '''
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="query-triples-close">librdf_query_triples_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_query_triples_close</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_query_triples_close </function></funcdef>
   <paramdef>librdf_query* <parameter>query</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>query</parameter></term>
   <listitem>
    <para>
      the query
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Close the query list query, and free all content since there is no 
   persistance.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="serializer">
<?dbhtml filename='serializer.html'>
<title>RDF Serializer</title>
<para>
This module provides RDF graph to syntax serialization support
via factory classes providing one or more particular target syntaxes.
</para>
<sect1>
<title>RDF Serializer Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-register-factory">librdf_serializer_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_register_factory</refname>
 <refpurpose>
   Register a serializer factory 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_serializer_register_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const char * <parameter>mime_type</parameter></paramdef>
   <paramdef>const char * <parameter>uri_string</parameter></paramdef>
   <paramdef>void (*<parameter>factory</parameter>)
     <funcparams>librdf_serializer_factory*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the name of the serializer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mime_type</parameter></term>
   <listitem>
    <para>
      MIME type of the syntax (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri_string</parameter></term>
   <listitem>
    <para>
      URI of the syntax (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      function to be called to register the factor parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="get-serializer-factory">librdf_get_serializer_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_get_serializer_factory</refname>
 <refpurpose>
      Get a serializer factory by name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_serializer_factory* <function>librdf_get_serializer_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const char * <parameter>mime_type</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>type_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the name of the factory (NULL or empty string if don't care)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mime_type</parameter></term>
   <listitem>
    <para>
      the MIME type of the syntax (NULL or empty string if not used)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type_uri</parameter></term>
   <listitem>
    <para>
      URI of syntax (NULL if not used)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If all fields are NULL, this means any parser supporting
   MIME Type <quote>application/rdf+xml</quote>
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the factory or NULL if not found
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-serializer">librdf_new_serializer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_serializer</refname>
 <refpurpose>
      Constructor - create a new librdf_serializer object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_serializer* <function>librdf_new_serializer </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const char * <parameter>mime_type</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>type_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the serializer factory name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mime_type</parameter></term>
   <listitem>
    <para>
      the MIME type of the syntax (NULL if not used)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type_uri</parameter></term>
   <listitem>
    <para>
      URI of syntax (NULL if not used)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_serializer</structname> object or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-serializer-from-factory">librdf_new_serializer_from_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_serializer_from_factory</refname>
 <refpurpose>
      Constructor - create a new librdf_serializer object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_serializer* <function>librdf_new_serializer_from_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_serializer_factory * <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      the serializer factory to use to create this serializer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_serializer</structname> object or NULL
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-serializer">librdf_free_serializer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_serializer</refname>
 <refpurpose>
      Destructor - destroys a librdf_serializer object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_serializer </function></funcdef>
   <paramdef>librdf_serializer * <parameter>serializer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      the serializer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-serialize-model">librdf_serializer_serialize_model</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_serialize_model</refname>
 <refpurpose>
      Turn a librdf_model into a serialized form
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_serializer_serialize_model </function></funcdef>
   <paramdef>librdf_serializer* <parameter>serializer</parameter></paramdef>
   <paramdef>FILE * <parameter>handle</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      the serializer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
      file handle to serialize to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      the base URI to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_model</structname> model to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-serialize-model-to-file">librdf_serializer_serialize_model_to_file</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_serialize_model_to_file</refname>
 <refpurpose>
      Write a librdf_model into a serialized form to a file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_serializer_serialize_model_to_file </function></funcdef>
   <paramdef>librdf_serializer* <parameter>serializer</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      the serializer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      filename to serialize to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      the base URI to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_model</structname> model to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="init-serializer">librdf_init_serializer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_serializer</refname>
 <refpurpose>
      Initialise the librdf_serializer class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_serializer </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-serializer">librdf_finish_serializer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_serializer</refname>
 <refpurpose>
      Terminate the librdf_serializer class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_serializer </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-set-error">librdf_serializer_set_error</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_set_error</refname>
 <refpurpose>
      Set the serializer error handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_serializer_set_error </function></funcdef>
   <paramdef>librdf_serializer* <parameter>serializer</parameter></paramdef>
   <paramdef>void * <parameter>user_data</parameter></paramdef>
   <paramdef>void (*<parameter>error_fn</parameter>)
     <funcparams>void *user_data, const char *msg, ...</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      the serializer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_data</parameter></term>
   <listitem>
    <para>
      user data to pass to function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>error_fn</parameter></term>
   <listitem>
    <para>
      pointer to the function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function will receive callbacks when the serializer fails.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-set-warning">librdf_serializer_set_warning</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_set_warning</refname>
 <refpurpose>
      Set the serializer warning handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_serializer_set_warning </function></funcdef>
   <paramdef>librdf_serializer* <parameter>serializer</parameter></paramdef>
   <paramdef>void * <parameter>user_data</parameter></paramdef>
   <paramdef>void (*<parameter>warning_fn</parameter>)
     <funcparams>void *user_data, const char *msg, ...</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      the serializer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_data</parameter></term>
   <listitem>
    <para>
      user data to pass to function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>warning_fn</parameter></term>
   <listitem>
    <para>
      pointer to the function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function will receive callbacks when the serializer gives a warning.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-get-feature">librdf_serializer_get_feature</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_get_feature</refname>
 <refpurpose>
      Get the value of a serializer feature
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>librdf_serializer_get_feature </function></funcdef>
   <paramdef>librdf_serializer* <parameter>serializer</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>feature</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      serializer object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>feature</parameter></term>
   <listitem>
    <para>
      URI of feature
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the value of the feature or NULL if no such feature
   exists or the value is empty.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-set-feature">librdf_serializer_set_feature</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_set_feature</refname>
 <refpurpose>
      Set the value of a serializer feature
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_serializer_set_feature </function></funcdef>
   <paramdef>librdf_serializer* <parameter>serializer</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>feature</parameter></paramdef>
   <paramdef>const char * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      serializer object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>feature</parameter></term>
   <listitem>
    <para>
      URI of feature
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      value to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure (negative if no such feature)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-set-namespace">librdf_serializer_set_namespace</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_set_namespace</refname>
 <refpurpose>
      Set a namespace URI/prefix mapping
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_serializer_set_namespace </function></funcdef>
   <paramdef>librdf_serializer* <parameter>serializer</parameter></paramdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>const char * <parameter>prefix</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      serializer object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      URI of namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prefix</parameter></term>
   <listitem>
    <para>
      prefix to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>RDF Serializer Raptor Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-raptor-init">librdf_serializer_raptor_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_raptor_init</refname>
 <refpurpose>
   Initialise the N-Triples RDF serializer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_serializer_raptor_init </function></funcdef>
   <paramdef>librdf_serializer * <parameter>serializer</parameter></paramdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serializer</parameter></term>
   <listitem>
    <para>
      the serializer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-raptor-register-factory">librdf_serializer_raptor_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_raptor_register_factory</refname>
 <refpurpose>
      Register the N-riples serializer with the RDF serializer factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_serializer_raptor_register_factory </function></funcdef>
   <paramdef>librdf_serializer_factory * <parameter>factory</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="serializer-raptor-constructor">librdf_serializer_raptor_constructor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_serializer_raptor_constructor</refname>
 <refpurpose>
      Initialise the raptor RDF serializer module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_serializer_raptor_constructor </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="storage">
<?dbhtml filename='storage.html'>
<title>RDF Model Storage</title>
<para>
This module provides storage for RDF models either in memory or
persistant storage.
</para>
<sect1>
<title>RDF Model Storage Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="init-storage">librdf_init_storage</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_storage</refname>
 <refpurpose>
   Initialise the librdf_storage module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_storage </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Initialises and registers all
   compiled storage modules.  Must be called before using any of the storage
   factory functions such as <function>librdf_get_storage_factory</function>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-storage">librdf_finish_storage</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_storage</refname>
 <refpurpose>
      Terminate the librdf_storage module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_storage </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-register-factory">librdf_storage_register_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_register_factory</refname>
 <refpurpose>
      Register a storage factory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_storage_register_factory </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>void (*<parameter>factory</parameter>)
     <funcparams>librdf_storage_factory*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the storage factory name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      pointer to function to call to register the factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="get-storage-factory">librdf_get_storage_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_get_storage_factory</refname>
 <refpurpose>
      Get a storage factory by name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_storage_factory* <function>librdf_get_storage_factory </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the factory name or NULL for the default factory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the factory object or NULL if there is no such factory
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-storage">librdf_new_storage</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_storage</refname>
 <refpurpose>
      Constructor - create a new librdf_storage object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_storage* <function>librdf_new_storage </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>char * <parameter>storage_name</parameter></paramdef>
   <paramdef>char * <parameter>name</parameter></paramdef>
   <paramdef>char * <parameter>options_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>storage_name</parameter></term>
   <listitem>
    <para>
      the storage factory name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      an identifier for the storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>options_string</parameter></term>
   <listitem>
    <para>
      options to initialise storage
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The options are encoded as described in <function>librdf_hash_from_string</function>
   and can be NULL if none are required.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_storage</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-storage-from-storage">librdf_new_storage_from_storage</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_storage_from_storage</refname>
 <refpurpose>
      Copy constructor - create a new librdf_storage object from an existing one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_storage* <function>librdf_new_storage_from_storage </function></funcdef>
   <paramdef>librdf_storage* <parameter>old_storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old_storage</parameter></term>
   <listitem>
    <para>
      the existing storage <structname>librdf_storage</structname> to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Should create a new storage in the same context as the existing one
   as appropriate for the storage.  For example, in a RDBMS storage
   it would be a new database, or in on disk it would be a new
   set of files.  This will mean automatically generating
   a new identifier for the storage, maybe based on the existing
   storage identifier.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_storage</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-storage-from-factory">librdf_new_storage_from_factory</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_storage_from_factory</refname>
 <refpurpose>
      Constructor - create a new librdf_storage object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_storage* <function>librdf_new_storage_from_factory </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>librdf_storage_factory* <parameter>factory</parameter></paramdef>
   <paramdef>char * <parameter>name</parameter></paramdef>
   <paramdef>librdf_hash* <parameter>options</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>factory</parameter></term>
   <listitem>
    <para>
      the factory to use to construct the storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      name to use for storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>options</parameter></term>
   <listitem>
    <para>
      <structname>librdf_hash</structname> of options to initialise storage
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If the options are present, they become owned by the storage
   and should no longer be used.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_storage</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-storage">librdf_free_storage</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_storage</refname>
 <refpurpose>
      Destructor - destroy a librdf_storage object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_storage </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-open">librdf_storage_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_open</refname>
 <refpurpose>
      Start a model / storage association
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_open </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_model* <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
      model stored
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is ended with <function>librdf_storage_close</function>
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-close">librdf_storage_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_close</refname>
 <refpurpose>
      End a model / storage association
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_close </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-size">librdf_storage_size</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_size</refname>
 <refpurpose>
      Get the number of statements stored
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_size </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    The number of statements or &lt; 0 if cannot be determined
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-add-statement">librdf_storage_add_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_add_statement</refname>
 <refpurpose>
      Add a statement to a storage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_add_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The passed-in statement is copied when added to the store, not
   shared with the store.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-add-statements">librdf_storage_add_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_add_statements</refname>
 <refpurpose>
      Add a stream of statements to the storage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_add_statements </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_stream* <parameter>statement_stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement_stream</parameter></term>
   <listitem>
    <para>
      <structname>librdf_stream</structname> of statements
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-remove-statement">librdf_storage_remove_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_remove_statement</refname>
 <refpurpose>
      Remove a statement from the storage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_remove_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-contains-statement">librdf_storage_contains_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_contains_statement</refname>
 <refpurpose>
      Test if a given statement is present in the storage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_contains_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if the storage contains the statement
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-serialise">librdf_storage_serialise</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_serialise</refname>
 <refpurpose>
      Serialise the storage as a librdf_stream of statemetns
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_storage_serialise </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-find-statements">librdf_storage_find_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_find_statements</refname>
 <refpurpose>
      search the storage for matching statements
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_storage_find_statements </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> partial statement to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the storage for a (partial) statement as described in
   <function>librdf_statement_match</function> and returns a <structname>librdf_stream</structname> of
   matching <structname>librdf_statement</structname> objects.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_stream</structname> of matching statements (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-get-sources">librdf_storage_get_sources</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_get_sources</refname>
 <refpurpose>
      return the sources (subjects) of arc in an RDF graph given arc (predicate) and target (object)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_storage_get_sources </function></funcdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node * <parameter>arc</parameter></paramdef>
   <paramdef>librdf_node * <parameter>target</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arc</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> arc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> target
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the storage for arcs matching the given arc and target
   and returns a list of the source <structname>librdf_node</structname> objects as an iterator
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-get-arcs">librdf_storage_get_arcs</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_get_arcs</refname>
 <refpurpose>
      return the arcs (predicates) of an arc in an RDF graph given source (subject) and target (object)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_storage_get_arcs </function></funcdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node * <parameter>source</parameter></paramdef>
   <paramdef>librdf_node * <parameter>target</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> target
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the storage for arcs matching the given source and target
   and returns a list of the arc <structname>librdf_node</structname> objects as an iterator
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-get-targets">librdf_storage_get_targets</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_get_targets</refname>
 <refpurpose>
      return the targets (objects) of an arc in an RDF graph given source (subject) and arc (predicate)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_storage_get_targets </function></funcdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node * <parameter>source</parameter></paramdef>
   <paramdef>librdf_node * <parameter>arc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arc</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> arc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the storage for targets matching the given source and arc
   and returns a list of the source <structname>librdf_node</structname> objects as an iterator
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-get-arcs-in">librdf_storage_get_arcs_in</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_get_arcs_in</refname>
 <refpurpose>
      return the properties pointing to the given resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_storage_get_arcs_in </function></funcdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-get-arcs-out">librdf_storage_get_arcs_out</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_get_arcs_out</refname>
 <refpurpose>
      return the properties pointing from the given resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_storage_get_arcs_out </function></funcdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects (may be empty) or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-has-arc-in">librdf_storage_has_arc_in</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_has_arc_in</refname>
 <refpurpose>
      check if a node has a given property pointing to it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_has_arc_in </function></funcdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
   <paramdef>librdf_node * <parameter>property</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> property node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if arc property does point to the resource node
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-has-arc-out">librdf_storage_has_arc_out</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_has_arc_out</refname>
 <refpurpose>
      check if a node has a given property pointing from it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_has_arc_out </function></funcdef>
   <paramdef>librdf_storage * <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node * <parameter>node</parameter></paramdef>
   <paramdef>librdf_node * <parameter>property</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> resource node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> property node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if arc property does point from the resource node
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-context-add-statement">librdf_storage_context_add_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_context_add_statement</refname>
 <refpurpose>
      Add a statement to a storage in a context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_context_add_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> context node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-context-remove-statement">librdf_storage_context_remove_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_context_remove_statement</refname>
 <refpurpose>
      Remove a statement from a storage in a context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_context_remove_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> context node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-context-serialise">librdf_storage_context_serialise</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_context_serialise</refname>
 <refpurpose>
      List all statements in a storage context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_storage_context_serialise </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> context node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL on failure or context is empty
 </para>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>In Memory List RDF Model Storage Implementation Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="storage-list-close">librdf_storage_list_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_list_close</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_list_close </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      the storage
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Close the storage list storage, and free all content since there is no 
   persistance.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-list-find-statements">librdf_storage_list_find_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_list_find_statements</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_storage_list_find_statements </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      the storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement to match
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Return a stream of statements matching the given statement (or
   all statements if NULL).  Parts (subject, predicate, object) of the
   statement can be empty in which case any statement part will match that.
   Uses <structname>librdf_statement_match</structname> to do the matching.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a <structname>librdf_stream</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-list-context-add-statement">librdf_storage_list_context_add_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_list_context_add_statement</refname>
 <refpurpose>
      Add a statement to a storage context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_list_context_add_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context_node</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-list-context-remove-statement">librdf_storage_list_context_remove_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_list_context_remove_statement</refname>
 <refpurpose>
      Remove a statement from a storage context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_list_context_remove_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context_node</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-list-context-serialise">librdf_storage_list_context_serialise</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_list_context_serialise</refname>
 <refpurpose>
      List all statements in a storage context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_storage_list_context_serialise </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context_node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL on failure or context is empty
 </para>
</refsect1>
</refentry>

</sect1>
<sect1>
<title>Multiple Hashes RDF Model Storage Implementation Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="storage-hashes-close">librdf_storage_hashes_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_hashes_close</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_hashes_close </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Close the storage hashes storage, and free all content since there is no 
   persistance.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-hashes-find-statements">librdf_storage_hashes_find_statements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_hashes_find_statements</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_storage_hashes_find_statements </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      the storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      the statement to match
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Return a stream of statements matching the given statement (or
   all statements if NULL).  Parts (subject, predicate, object) of the
   statement can be empty in which case any statement part will match that.
   Uses <structname>librdf_statement_match</structname> to do the matching.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a <structname>librdf_stream</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-hashes-context-add-statement">librdf_storage_hashes_context_add_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_hashes_context_add_statement</refname>
 <refpurpose>
      Add a statement to a storage context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_hashes_context_add_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context_node</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-hashes-context-remove-statement">librdf_storage_hashes_context_remove_statement</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_hashes_context_remove_statement</refname>
 <refpurpose>
      Remove a statement from a storage context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_storage_hashes_context_remove_statement </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context_node</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> statement to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="storage-hashes-context-serialise">librdf_storage_hashes_context_serialise</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_storage_hashes_context_serialise</refname>
 <refpurpose>
      List all statements in a storage context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_storage_hashes_context_serialise </function></funcdef>
   <paramdef>librdf_storage* <parameter>storage</parameter></paramdef>
   <paramdef>librdf_node* <parameter>context_node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
      <structname>librdf_storage</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context_node</parameter></term>
   <listitem>
    <para>
      <structname>librdf_node</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    <structname>librdf_stream</structname> of statements or NULL on failure or context is empty
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="stream">
<?dbhtml filename='stream.html'>
<title>RDF Model Serialisation</title>
<para>
This module provides a method to generate a stream of statements,
suitable for outputing from RDF/XML parsers, returning as the
results of queries and serialising models in order to manipulate
them or transform into another syntax.
</para>
<sect1>
<title>RDF Statement Stream Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="new-stream">librdf_new_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_stream</refname>
 <refpurpose>
   Constructor - create a new librdf_stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_new_stream </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>int (*<parameter>is_end_method</parameter>)
     <funcparams>void*</funcparams></paramdef>
   <paramdef>int (*<parameter>next_method</parameter>)
     <funcparams>void*</funcparams></paramdef>
   <paramdef>void* (*<parameter>get_method</parameter>)
     <funcparams>void*, int</funcparams></paramdef>
   <paramdef>void (*<parameter>finished_method</parameter>)
     <funcparams>void*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      context to pass to the stream implementing objects
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_end_method</parameter></term>
   <listitem>
    <para>
      pointer to function to test for end of stream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>next_method</parameter></term>
   <listitem>
    <para>
      pointer to function to move to the next statement in stream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>get_method</parameter></term>
   <listitem>
    <para>
      pointer to function to get the current statement
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>finished_method</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Creates a new stream with an implementation based on the passed in
   functions.  The functions next_statement and end_of_stream will be called
   multiple times until either of them signify the end of stream by
   returning NULL or non 0 respectively.  The finished function is called
   once only when the stream object is destroyed with <function>librdf_free_stream</function>
   </para><para>

   A mapping function can be set for the stream using <function>librdf_stream_set_map</function>
   function which allows the statements generated by the stream to be
   filtered and/or altered as they are generated before passing back
   to the user.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
     a new <structname>librdf_stream</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-stream">librdf_free_stream</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_stream</refname>
 <refpurpose>
      Destructor - destroy an libdf_stream object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_stream </function></funcdef>
   <paramdef>librdf_stream* <parameter>stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      <structname>librdf_stream</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="stream-end">librdf_stream_end</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_stream_end</refname>
 <refpurpose>
      Test if the stream has ended
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_stream_end </function></funcdef>
   <paramdef>librdf_stream* <parameter>stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      <structname>librdf_stream</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 at end of stream.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="stream-next">librdf_stream_next</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_stream_next</refname>
 <refpurpose>
      Move to the next librdf_statement in the stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_stream_next </function></funcdef>
   <paramdef>librdf_stream* <parameter>stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      <structname>librdf_stream</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if the stream has finished
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="stream-get-object">librdf_stream_get_object</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_stream_get_object</refname>
 <refpurpose>
      Get the current librdf_statement in the stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_statement* <function>librdf_stream_get_object </function></funcdef>
   <paramdef>librdf_stream* <parameter>stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      <structname>librdf_stream</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the current <structname>librdf_statement</structname> object or NULL at end of stream.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="stream-get-context">librdf_stream_get_context</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_stream_get_context</refname>
 <refpurpose>
      Get the context of the current object on the stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_stream_get_context </function></funcdef>
   <paramdef>librdf_stream* <parameter>stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_stream</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    The context or NULL if the stream has finished.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="stream-set-map">librdf_stream_set_map</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_stream_set_map</refname>
 <refpurpose>
      Set the filtering/mapping function for the stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_stream_set_map </function></funcdef>
   <paramdef>librdf_stream* <parameter>stream</parameter></paramdef>
   <paramdef>librdf_statement* (*<parameter>map</parameter>)
     <funcparams>void* map_context, librdf_statement* statement</funcparams></paramdef>
   <paramdef>void (*<parameter>free_context</parameter>)
     <funcparams>void *map_context</funcparams></paramdef>
   <paramdef>void* <parameter>map_context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      <structname>librdf_stream</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>map</parameter></term>
   <listitem>
    <para>
      mapping function.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>free_context</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>map_context</parameter></term>
   <listitem>
    <para>
      context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function 
   is called with the mapping context and the next statement.  The return
   value of the mapping function is then passed on to the user, if not NULL.
   If NULL is returned, that statement is not emitted.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-stream-from-node-iterator">librdf_new_stream_from_node_iterator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_stream_from_node_iterator</refname>
 <refpurpose>
      Constructor - create a new librdf_stream from an iterator of nodes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_stream* <function>librdf_new_stream_from_node_iterator </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
   <paramdef>librdf_statement* <parameter>statement</parameter></paramdef>
   <paramdef>unsigned int <parameter>field</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      <structname>librdf_iterator</structname> of <structname>librdf_node</structname> objects
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>statement</parameter></term>
   <listitem>
    <para>
      <structname>librdf_statement</structname> prototype with one NULL node space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>field</parameter></term>
   <listitem>
    <para>
      node part of statement
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Creates a new <structname>librdf_stream</structname> using the passed in <structname>librdf_iterator</structname>
   which generates a series of <structname>librdf_node</structname> objects.  The resulting
   nodes are then inserted into the given statement and returned.
   The field attribute indicates which statement node is being generated.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_stream</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="stream-print">librdf_stream_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_stream_print</refname>
 <refpurpose>
      print the stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_stream_print </function></funcdef>
   <paramdef>librdf_stream * <parameter>stream</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      the stream object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      the FILE stream to print to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This prints the remaining statements of the stream to the given
   file handle.  Note that after this method is called the stream
   will be empty so that <function>librdf_stream_end</function> will always be true
   and <function>librdf_stream_next</function> will always return NULL.  The only
   useful operation is to dispose of the stream with the
   <function>librdf_free_stream</function> destructor.
   </para><para>

   This method is for debugging and the format of the output should
   not be relied on.
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="iterator">
<?dbhtml filename='iterator.html'>
<title>Data Iterators</title>
<para>
The iterator provides a generic way to receive a sequence of values
(order may or may not be import) from objects, usually generated
on demand.
</para>
<sect1>
<title>Iterator Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="new-iterator">librdf_new_iterator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_iterator</refname>
 <refpurpose>
   Constructor - create a new librdf_iterator object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_new_iterator </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>void* <parameter>context</parameter></paramdef>
   <paramdef>int (*<parameter>is_end_method</parameter>)
     <funcparams>void*</funcparams></paramdef>
   <paramdef>int (*<parameter>next_method</parameter>)
     <funcparams>void*</funcparams></paramdef>
   <paramdef>void* (*<parameter>get_method</parameter>)
     <funcparams>void*, int</funcparams></paramdef>
   <paramdef>void (*<parameter>finished_method</parameter>)
     <funcparams>void*</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      context to pass to the iterator functions
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_end_method</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>next_method</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>get_method</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>finished_method</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_iterator</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-iterator">librdf_free_iterator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_iterator</refname>
 <refpurpose>
      Destructor - destroy a librdf_iterator object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_iterator </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-have-elements">librdf_iterator_have_elements</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_have_elements</refname>
 <refpurpose>
      Test if the iterator has finished
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_iterator_have_elements </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   DEPRECATED - use !librdf_iterator_end(iterator)
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    0 if the iterator has finished
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-end">librdf_iterator_end</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_end</refname>
 <refpurpose>
      Test if the iterator has finished
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_iterator_end </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if the iterator has finished
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-next">librdf_iterator_next</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_next</refname>
 <refpurpose>
      Move to the next iterator element
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_iterator_next </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if the iterator has finished
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-get-object">librdf_iterator_get_object</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_get_object</refname>
 <refpurpose>
      Get the current object from the iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_iterator_get_object </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    The next element or NULL if the iterator has finished.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-get-context">librdf_iterator_get_context</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_get_context</refname>
 <refpurpose>
      Get the context of the current object on the iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_iterator_get_context </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    The context or NULL if the iterator has finished.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-get-key">librdf_iterator_get_key</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_get_key</refname>
 <refpurpose>
      Get the key of the current object on the iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_iterator_get_key </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    The context or NULL if the iterator has finished.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-get-value">librdf_iterator_get_value</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_get_value</refname>
 <refpurpose>
      Get the value of the current object on the iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_iterator_get_value </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the <structname>librdf_iterator</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    The context or NULL if the iterator has finished.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="iterator-add-map">librdf_iterator_add_map</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_iterator_add_map</refname>
 <refpurpose>
      Add a librdf_iterator mapping function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_iterator_add_map </function></funcdef>
   <paramdef>librdf_iterator* <parameter>iterator</parameter></paramdef>
   <paramdef>void* (*<parameter>fn</parameter>)
     <funcparams>void *context, void *element</funcparams></paramdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
      the iterator
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
      the function to operate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
      the context to pass to the map function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Adds an iterator mapping function which operates over the iterator to
   select which elements are returned; it will be applied as soon as
   this method is called.
   </para><para>

   Several mapping functions can be added and they are applied in
   the order given
   </para><para>

   The mapping function should return non 0 to allow the element to be
   returned.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    Non 0 on failure
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="list">
<?dbhtml filename='list.html'>
<title>Lists</title>
<para>
The list module provides a simple in-memory list.
</para>
<sect1>
<title>List Class</title>
<para>
This class is implemented as a stack, new items are added to the front
of the list.
</para>
<refentry>
<refmeta>
<refentrytitle><phrase id="new-list">librdf_new_list</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_list</refname>
 <refpurpose>
   Constructor - create a new librdf_list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_list* <function>librdf_new_list </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_list</structname> or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-list">librdf_free_list</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_list</refname>
 <refpurpose>
      Destructor - destroy a librdf_list object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_list </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-clear">librdf_list_clear</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_clear</refname>
 <refpurpose>
      empty an librdf_list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_list_clear </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-add">librdf_list_add</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_add</refname>
 <refpurpose>
      add a data item to the end of a librdf_list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_list_add </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      the data value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Equivalent to the list 'push' notion, thus if <function>librdf_list_pop</function>
   is called after this, it will return the value added here.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-unshift">librdf_list_unshift</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_unshift</refname>
 <refpurpose>
      add a data item to the start of a librdf_list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_list_unshift </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      the data value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   if <function>librdf_list_shift</function> is called after this, it will return the value
   added here.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-remove">librdf_list_remove</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_remove</refname>
 <refpurpose>
      remove a data item from an librdf_list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>librdf_list_remove </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      the data item
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The search is done using the 'equals' function which may be set
   by <function>librdf_list_set_equals</function> or by straight comparison of pointers
   if not set.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the data stored or NULL on failure (not found or list empty)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-shift">librdf_list_shift</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_shift</refname>
 <refpurpose>
      remove and return the data at the start of the list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_list_shift </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the data object or NULL if the list is empty
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-pop">librdf_list_pop</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_pop</refname>
 <refpurpose>
      remove and return the data at the end of the list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void* <function>librdf_list_pop </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    the data object or NULL if the list is empty
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-contains">librdf_list_contains</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_contains</refname>
 <refpurpose>
      check for presence of data item in list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_list_contains </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      the data value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The search is done using the 'equals' function which may be set
   by <function>librdf_list_set_equals</function> or by straight comparison of pointers
   if not set.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if item was found
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-size">librdf_list_size</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_size</refname>
 <refpurpose>
      return the length of the list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_list_size </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    length of the list
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-set-equals">librdf_list_set_equals</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_set_equals</refname>
 <refpurpose>
      set the equals function for the list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_list_set_equals </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
   <paramdef>int (*<parameter>equals</parameter>)
     <funcparams>void* data1, void *data2</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>equals</parameter></term>
   <listitem>
    <para>
      the equals function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function given is used when comparing items in the list
   during searches such as those done in <function>librdf_list_remove</function> or
   <function>librdf_list_contains</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-get-iterator">librdf_list_get_iterator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_get_iterator</refname>
 <refpurpose>
      get an iterator for the list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_iterator* <function>librdf_list_get_iterator </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_iterator</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="list-foreach">librdf_list_foreach</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_list_foreach</refname>
 <refpurpose>
      apply a function for each data item in a librdf_list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_list_foreach </function></funcdef>
   <paramdef>librdf_list* <parameter>list</parameter></paramdef>
   <paramdef>void (*<parameter>fn</parameter>)
     <funcparams>void *, void *</funcparams></paramdef>
   <paramdef>void * <parameter>user_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      <structname>librdf_list</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
      pointer to function to apply that takes data pointer and user data parameters
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_data</parameter></term>
   <listitem>
    <para>
      user data for applied function 
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>
</chapter>

<chapter id="uri">
<?dbhtml filename='uri.html'>
<title>URIs</title>
<para>
This class provides very simple URI functionality - mostly just storage
and comparison.
</para>
<sect1>
<title>URI Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="init-uri">librdf_init_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_init_uri</refname>
 <refpurpose>
   Initialise the librdf_uri class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_init_uri </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="finish-uri">librdf_finish_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_finish_uri</refname>
 <refpurpose>
      Terminate the librdf_uri class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_finish_uri </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-uri">librdf_new_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_uri</refname>
 <refpurpose>
      Constructor - create a new librdf_uri object from a URI string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_new_uri </function></funcdef>
   <paramdef>librdf_world * <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>uri_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      redland world object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri_string</parameter></term>
   <listitem>
    <para>
      URI in string form
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   A new URI is constructed from a copy of the string.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_uri</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-uri-from-uri">librdf_new_uri_from_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_uri_from_uri</refname>
 <refpurpose>
      Copy constructor - create a new librdf_uri object from an existing librdf_uri object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_new_uri_from_uri </function></funcdef>
   <paramdef>librdf_uri* <parameter>old_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_uri</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-uri-from-uri-local-name">librdf_new_uri_from_uri_local_name</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_uri_from_uri_local_name</refname>
 <refpurpose>
      Copy constructor - create a new librdf_uri object from an existing librdf_uri object and a local name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_new_uri_from_uri_local_name </function></funcdef>
   <paramdef>librdf_uri* <parameter>old_uri</parameter></paramdef>
   <paramdef>const char * <parameter>local_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>local_name</parameter></term>
   <listitem>
    <para>
      local name to append to URI
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_uri</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-uri-normalised-to-base">librdf_new_uri_normalised_to_base</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_uri_normalised_to_base</refname>
 <refpurpose>
      Constructor - create a new librdf_uri object from a URI string stripped of the source URI, made relative to the base URI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_new_uri_normalised_to_base </function></funcdef>
   <paramdef>const char * <parameter>uri_string</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>source_uri</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri_string</parameter></term>
   <listitem>
    <para>
      URI in string form
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>source_uri</parameter></term>
   <listitem>
    <para>
      source URI to remove
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      base URI to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_uri</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-uri-relative-to-base">librdf_new_uri_relative_to_base</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_uri_relative_to_base</refname>
 <refpurpose>
      Constructor - create a new librdf_uri object from a URI string relative to a base URI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_new_uri_relative_to_base </function></funcdef>
   <paramdef>librdf_uri* <parameter>base_uri</parameter></paramdef>
   <paramdef>const char * <parameter>uri_string</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>base_uri</parameter></term>
   <listitem>
    <para>
      absolute base URI
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uri_string</parameter></term>
   <listitem>
    <para>
      relative URI string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   An empty uri_string or NULL is equivalent to 
   librdf_new_uri_from_uri(base_uri)
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_uri</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="new-uri-from-filename">librdf_new_uri_from_filename</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_new_uri_from_filename</refname>
 <refpurpose>
      Constructor - create a new librdf_uri object from a filename
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_uri* <function>librdf_new_uri_from_filename </function></funcdef>
   <paramdef>librdf_world* <parameter>world</parameter></paramdef>
   <paramdef>const char * <parameter>filename</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>world</parameter></term>
   <listitem>
    <para>
      Redland <structname>librdf_world</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      filename
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new <structname>librdf_uri</structname> object or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="free-uri">librdf_free_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_free_uri</refname>
 <refpurpose>
      Destructor - destroy a librdf_uri object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_free_uri </function></funcdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-as-string">librdf_uri_as_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_as_string</refname>
 <refpurpose>
      Get a pointer to the string representation of the URI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_uri_as_string </function></funcdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a shared pointer to the URI string representation. 
 </para>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    does not allocate a new string so the caller must not free it.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    string representation of URI
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-as-counted-string">librdf_uri_as_counted_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_as_counted_string</refname>
 <refpurpose>
      Get a pointer to the string representation of the URI with length
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_uri_as_counted_string </function></funcdef>
   <paramdef>librdf_uri * <parameter>uri</parameter></paramdef>
   <paramdef>size_t* <parameter>len_p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len_p</parameter></term>
   <listitem>
    <para>
      pointer to location to store length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a shared pointer to the URI string representation. 
 </para>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    does not allocate a new string so the caller must not free it.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    string representation of URI
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-get-digest">librdf_uri_get_digest</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_get_digest</refname>
 <refpurpose>
      Get a digest for the URI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>librdf_digest* <function>librdf_uri_get_digest </function></funcdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Generates a digest object for the URI.  The digest factory used is
   determined at class initialisation time by <function>librdf_init_uri</function>.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    new <structname>librdf_digest</structname> object or NULL on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-print">librdf_uri_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_print</refname>
 <refpurpose>
      Print the URI to the given file handle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_uri_print </function></funcdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
   <paramdef>FILE * <parameter>fh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fh</parameter></term>
   <listitem>
    <para>
      <structname>FILE</structname> handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-to-string">librdf_uri_to_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_to_string</refname>
 <refpurpose>
      Format the URI as a string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_uri_to_string </function></funcdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    this method allocates a new string since this is a _to_ method
   and the caller must free the resulting memory.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    string representation of the URI or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-to-counted-string">librdf_uri_to_counted_string</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_to_counted_string</refname>
 <refpurpose>
      Format the URI as a counted string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char* <function>librdf_uri_to_counted_string </function></funcdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
   <paramdef>size_t* <parameter>len_p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len_p</parameter></term>
   <listitem>
    <para>
      pointer to location to store length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    this method allocates a new string since this is a _to_ method
   and the caller must free the resulting memory.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    string representation of the URI or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-equals">librdf_uri_equals</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_equals</refname>
 <refpurpose>
      Compare two librdf_uri objects for equality
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_uri_equals </function></funcdef>
   <paramdef>librdf_uri* <parameter>first_uri</parameter></paramdef>
   <paramdef>librdf_uri* <parameter>second_uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>first_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object 1
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>second_uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object 2
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if the objects are equal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-is-file-uri">librdf_uri_is_file_uri</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_is_file_uri</refname>
 <refpurpose>
      Test if a URI points to a filename
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_uri_is_file_uri </function></funcdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    0 if the URI points to a file
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="uri-to-filename">librdf_uri_to_filename</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_uri_to_filename</refname>
 <refpurpose>
      Return pointer to filename of URI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char* <function>librdf_uri_to_filename </function></funcdef>
   <paramdef>librdf_uri* <parameter>uri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uri</parameter></term>
   <listitem>
    <para>
      <structname>librdf_uri</structname> object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a pointer to a newly allocated buffer that
   the caller must free.  This will fail if the URI
 </para>
</refsect1>
<refsect1>
 <title>is not a file</title>
 <para>
    URI.  This can be checked with <structname>librdf_uri_is_file_uri</structname>
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    pointer to filename or NULL on failure
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>


<chapter id="utf8">
<?dbhtml filename='utf8.html'>
<title>UTF-8</title>
<para>
This utility class provides some functions for UTF-8 to/from ISO Latin-1
de/encoding.
</para>
<sect1>
<title>UTF8 Class</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="unicode-char-to-utf8">librdf_unicode_char_to_utf8</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_unicode_char_to_utf8</refname>
 <refpurpose>
   Convert a Unicode character to UTF-8 encoding
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_unicode_char_to_utf8 </function></funcdef>
   <paramdef>librdf_unichar <parameter>c</parameter></paramdef>
   <paramdef>byte * <parameter>output</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      Unicode character
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>output</parameter></term>
   <listitem>
    <para>
      UTF-8 string buffer or NULL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If buffer is NULL, then will calculate the length rather than
   perform it.  This can be used by the caller to allocate space
   and then re-call this function with the new buffer.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    bytes written to output buffer or &lt;0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="utf8-to-unicode-char">librdf_utf8_to_unicode_char</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_utf8_to_unicode_char</refname>
 <refpurpose>
      Convert an UTF-8 encoded buffer to a Unicode character
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_utf8_to_unicode_char </function></funcdef>
   <paramdef>librdf_unichar * <parameter>output</parameter></paramdef>
   <paramdef>const byte * <parameter>input</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>output</parameter></term>
   <listitem>
    <para>
      Pointer to the Unicode character or NULL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>input</parameter></term>
   <listitem>
    <para>
      UTF-8 string buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If output is NULL, then will calculate the number of bytes that
   will be used from the input buffer and not perform the conversion.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    bytes used from input buffer or &lt;0 on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="utf8-to-latin1">librdf_utf8_to_latin1</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_utf8_to_latin1</refname>
 <refpurpose>
      Convert a UTF-8 string to ISO Latin-1
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>byte* <function>librdf_utf8_to_latin1 </function></funcdef>
   <paramdef>const byte * <parameter>input</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
   <paramdef>int * <parameter>output_length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>input</parameter></term>
   <listitem>
    <para>
      UTF-8 string buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>output_length</parameter></term>
   <listitem>
    <para>
      Pointer to variable to store resulting string length or NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Converts the given UTF-8 string to the ISO Latin-1 subset of
   Unicode (characters 0x00-0xff), discarding any out of range
   characters.
   </para><para>

   If the output_length pointer is not NULL, the returned string
   length will be stored there.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    pointer to new ISO Latin-1 string or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="latin1-to-utf8">librdf_latin1_to_utf8</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_latin1_to_utf8</refname>
 <refpurpose>
      Convert an ISO Latin-1 encoded string to UTF-8
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>byte* <function>librdf_latin1_to_utf8 </function></funcdef>
   <paramdef>const byte * <parameter>input</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
   <paramdef>int * <parameter>output_length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>input</parameter></term>
   <listitem>
    <para>
      ISO Latin-1 string buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>output_length</parameter></term>
   <listitem>
    <para>
      Pointer to variable to store resulting string length or NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Converts the given ISO Latin-1 string to an UTF-8 encoded string
   representing the same content.  This is lossless.
   </para><para>

   If the output_length pointer is not NULL, the returned string
   length will be stored there.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    pointer to new UTF-8 string or NULL on failure
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="utf8-print">librdf_utf8_print</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_utf8_print</refname>
 <refpurpose>
      Print a UTF-8 string to a stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>librdf_utf8_print </function></funcdef>
   <paramdef>const byte * <parameter>input</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
   <paramdef>FILE * <parameter>stream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>input</parameter></term>
   <listitem>
    <para>
      UTF-8 string buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      buffer size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
      FILE* stream
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Pretty prints the UTF-8 string in a pseudo-C character
   format like \u&lt;hex digits&gt; when the characters fail
   the <function>isprint</function> test.
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>


<chapter id="heuristics">
<?dbhtml filename='heuristics.html'>
<title>Heuristics</title>
<para>
This module provides utility functions that cross other modules and classes.
</para>
<sect1>
<title>Heuristic functions</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="heuristic-object-is-literal">librdf_heuristic_object_is_literal</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_heuristic_object_is_literal</refname>
 <refpurpose>
   try to guess if an object string is a literal or a resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>librdf_heuristic_object_is_literal </function></funcdef>
   <paramdef>char * <parameter>object</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>object</parameter></term>
   <listitem>
    <para>
      string object to guess type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The guessing is done by assuming the object is a URL if it matches
   ^[<function>isalnum</function>]+:[^<function>isblank</function>]+$
   </para><para>

   This will be fooled by literals of form 'thing:non-blank-thing' but
   is good enough.
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    non 0 if object is probably a literal
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="heuristic-gen-name">librdf_heuristic_gen_name</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>librdf_heuristic_gen_name</refname>
 <refpurpose>
      Generate a new name from an existing name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>librdf_heuristic_gen_name </function></funcdef>
   <paramdef>char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      the name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Adds an integer or increases the integer at the end of the name
   in order to generate a new one
 </para>
</refsect1>
<refsect1>
 <title>Return value</title>
 <para>
    a new name or NULL on failure
 </para>
</refsect1>
</refentry>

</sect1>
</chapter>


<appendix id="licenses">
<?dbhtml filename='licenses.html'>
<title>GNU Free Documentation License</title>

<para>
See also the GNU site copy of the license:
<ulink url="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</ulink>
which may have a newer version you can use.
</para>

  <literallayout class="monospaced">
                GNU Free Documentation License
                   Version 1.1, March 2000

 Copyright (C) 2000  Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


0. PREAMBLE

The purpose of this License is to make a manual, textbook, or other
written document "free" in the sense of freedom: to assure everyone
the effective freedom to copy and redistribute it, with or without
modifying it, either commercially or noncommercially.  Secondarily,
this License preserves for the author and publisher a way to get
credit for their work, while not being considered responsible for
modifications made by others.

This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.


1. APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work that contains a
notice placed by the copyright holder saying it can be distributed
under the terms of this License.  The "Document", below, refers to any
such manual or work.  Any member of the public is a licensee, and is
addressed as "you".

A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A "Secondary Section" is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (For example, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.

The "Cover Texts" are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.

A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, whose contents can be viewed and edited directly and
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup has been designed to thwart or discourage
subsequent modification by readers is not Transparent.  A copy that is
not "Transparent" is called "Opaque".

Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML designed for human modification.  Opaque formats include
PostScript, PDF, proprietary formats that can be read and edited only
by proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML produced by some word processors for output
purposes only.

The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.


2. VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.


3. COPYING IN QUANTITY

If you publish printed copies of the Document numbering more than 100,
and the Document's license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a publicly-accessible computer-network location containing a complete
Transparent copy of the Document, free of added material, which the
general network-using public has access to download anonymously at no
charge using public-standard network protocols.  If you use the latter
option, you must take reasonably prudent steps, when you begin
distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.


4. MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

A. Use in the Title Page (and on the covers, if any) a title distinct
   from that of the Document, and from those of previous versions
   (which should, if there were any, be listed in the History section
   of the Document).  You may use the same title as a previous version
   if the original publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or entities
   responsible for authorship of the modifications in the Modified
   Version, together with at least five of the principal authors of the
   Document (all of its principal authors, if it has less than five).
C. State on the Title page the name of the publisher of the
   Modified Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modifications
   adjacent to the other copyright notices.
F. Include, immediately after the copyright notices, a license notice
   giving the public permission to use the Modified Version under the
   terms of this License, in the form shown in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections
   and required Cover Texts given in the Document's license notice.
H. Include an unaltered copy of this License.
I. Preserve the section entitled "History", and its title, and add to
   it an item stating at least the title, year, new authors, and
   publisher of the Modified Version as given on the Title Page.  If
   there is no section entitled "History" in the Document, create one
   stating the title, year, authors, and publisher of the Document as
   given on its Title Page, then add an item describing the Modified
   Version as stated in the previous sentence.
J. Preserve the network location, if any, given in the Document for
   public access to a Transparent copy of the Document, and likewise
   the network locations given in the Document for previous versions
   it was based on.  These may be placed in the "History" section.
   You may omit a network location for a work that was published at
   least four years before the Document itself, or if the original
   publisher of the version it refers to gives permission.
K. In any section entitled "Acknowledgements" or "Dedications",
   preserve the section's title, and preserve in the section all the
   substance and tone of each of the contributor acknowledgements
   and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document,
   unaltered in their text and in their titles.  Section numbers
   or the equivalent are not considered part of the section titles.
M. Delete any section entitled "Endorsements".  Such a section
   may not be included in the Modified Version.
N. Do not retitle any existing section as "Endorsements"
   or to conflict in title with any Invariant Section.

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.

You may add a section entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.


5. COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections entitled "History"
in the various original documents, forming one section entitled
"History"; likewise combine any sections entitled "Acknowledgements",
and any sections entitled "Dedications".  You must delete all sections
entitled "Endorsements."


6. COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.



7. AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, does not as a whole count as a Modified Version
of the Document, provided no compilation copyright is claimed for the
compilation.  Such a compilation is called an "aggregate", and this
License does not apply to the other self-contained works thus compiled
with the Document, on account of their being thus compiled, if they
are not themselves derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one quarter
of the entire aggregate, the Document's Cover Texts may be placed on
covers that surround only the Document within the aggregate.
Otherwise they must appear on covers around the whole aggregate.


8. TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License provided that you also include the
original English version of this License.  In case of a disagreement
between the translation and the original English version of this
License, the original English version will prevail.


9. TERMINATION

You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.


10. FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns. See
http:///www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.


ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

      Copyright (c)  YEAR  YOUR NAME.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".

If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no
Front-Cover Texts, write "no Front-Cover Texts" instead of
"Front-Cover Texts being LIST"; likewise for Back-Cover Texts.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
  </literallayout>
 </appendix>

</book>
